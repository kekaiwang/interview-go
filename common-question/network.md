[toc]

## HTTP

### http

#### HTTP 长连接和短连接的理解？分别应用于哪些场景？

- **在 HTTP/1.0 中默认使用短连接**。
也就是说，客户端和服务器每进行一次 HTTP 操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个 HTML 或其他类型的 Web 页中包含有其他的 Web 资源（如：JavaScript 文件、图像文件、CSS 文件等），每遇到这样一个 Web 资源，浏览器就会重新建立一个 HTTP 会话。
- **从 HTTP/1.1 起，默认使用长连接**
用以保持连接特性。使用长连接的 HTTP 协议，会在响应头加入这行代 `Connection:keep-alive`
在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输 HTTP 数据的 TCP 连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。
Keep-Alive 不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如：Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。

#### 一个 TCP 连接可以对应几个 HTTP 请求？

如果维持连接，一个 TCP 连接是可以发送多个 HTTP 请求的。

#### 一个 TCP 连接中 HTTP 请求发送可以一起发送么

**比如一起发三个请求，再三个响应一起接收**？

HTTP/1.1 存在一个问题，单个 TCP 连接在同一时刻只能处理一个请求，意思是：两个请求的生命周期不能重叠，任意两个 HTTP 请求从开始到结束的时间在同一个 TCP 连接里不能重叠。
虽然 HTTP/1.1 规范中规定了 Pipelining 来试图解决这个问题，但是这个功能在浏览器中默认是关闭的。但是，**HTTP2 提供了 Multiplexing 多路传输特性，可以在一个 TCP 连接中同时完成多个 HTTP 请求**。

#### 为什么有的时候刷新页面不需要重新建立 SSL 连接？

TCP 连接有的时候会被浏览器和服务端维持一段时间。TCP 不需要重新建立，SSL 自然也会用之前的。
**TCP 连接最长 2 小时**

#### 浏览器对同一 Host 建立 TCP 连接到数量有没有限制？

Chrome 最多允许对同一个 Host 建立六个 TCP 连接。不同的浏览器有一些区别。
如果图片都是 HTTPS 连接并且在同一个域名下，那么浏览器在 SSL 握手之后会和服务器商量能不能用 HTTP2，如果能的话就使用 Multiplexing 功能在这个连接上进行多路传输。不过也未必会所有挂在这个域名的资源都会使用一个 TCP 连接去获取，但是可以确定的是 Multiplexing 很可能会被用到。

如果发现用不了 HTTP2 呢？或者用不了 HTTPS（现实中的 HTTP2 都是在 HTTPS 上实现的，所以也就是只能使用 HTTP/1.1）。那浏览器就会在一个 HOST 上建立多个 TCP 连接，连接数量的最大限制取决于浏览器设置，这些连接会在空闲的时候被浏览器用来发送新的请求，如果所有的连接都正在发送请求呢？那其他的请求就只能等等了。

#### 1.0 和 1.1、1.2 的主要变化？

**HTTP1.1 的主要变化**：

1. HTTP1.0 经过多年发展，在 1.1 提出了改进。**首先是提出了长连接**，HTTP 可以在一次 TCP 连接中不断发送请求。
2. 然后 HTTP1.1 支持只发送 header 而不发送 body。原因是先用 header 判断能否成功，再发数据，节约带宽，事实上，post 请求默认就是这样做的。
3. HTTP1.1 的 host 字段。由于虚拟主机可以支持多个域名，所以一般将域名解析后得到 host。

**HTTP2.0 的主要变化**：

1. **支持多路复用**
同一个连接可以并发处理多个请求，方法是把 HTTP数据包拆为多个帧，并发有序的发送，根据序号在另一端进行重组，而不需要一个个 HTTP请求顺序到达；
2. **支持服务端推送**
就是服务端在 HTTP 请求到达后，除了返回数据之外，还推送了额外的内容给客户端；例如服务端可以主动把JS和CSS文件推送给客户端，而不需要客户端解析HTML时再发送这些请求。
3. **压缩了请求头**
同时基本单位是二进制帧流，这样的数据占用空间更少；HTTP/2对消息头采用HPACK（专为http/2头部设计的压缩格式）进行压缩传输，能够节省消息头占用的网络的流量
4. **适用于 HTTPS 场景**
因为其在 HTTP和 TCP 中间加了一层 SSL 层。

#### http与https的区别

1. http 是超文本传输协议，**明文传输**，https 是具有安全性的 ssl 加密传输。
2. 端口 http 默认80，https 默认443。
3. http 是**无状态协议**(无状态是指对事务没有记忆能力，缺少状态意味对后续处理需要的信息没办法提供)，https是ssl+http构建的可进行加密传输身份认证的网络协议。
4. https协议需要证书，一般需要收费。

#### HTTPS优点

1. 使用 HTTPS 协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；
2. HTTPS 协议是由 SSL + HTTP 协议构建的可进行加密传输、身份认证的网络协议，要比 HTTP 协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性；
3. HTTPS 是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。

#### HTTPS缺点

1. HTTPS 协议握手阶段比较费时，会使页面的加载时间延长近 50%，增加 10% 到 20% 的耗电；
2. HTTPS 连接缓存不如 HTTP 高效，会增加数据开销和功耗，甚至已有的安全措施也会因此而受到影响；
3. SSL 证书需要钱，功能越强大的证书费用越高，个人网站、小网站没有必要一般不会用；
4. SSL 证书通常需要绑定 IP，不能在同一 IP 上绑定多个域名，IPv4 资源不可能支撑这个消耗；
5. HTTPS 协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用。最关键的，SSL 证书的信用链体系并不安全，特别是在某些国家可以控制 CA 根证书的情况下，中间人攻击一样可行。

> 443端口即网页浏览端口，主要是用于HTTPS服务，网页浏览端口，能提供加密和通过安全端口传输的另一种HTTP。

#### https的过程

1. client向server发送请求 `https://baidu.com`，然后连接到server的443端口，发送的信息主要是随机值1和客户端支持的加密算法。
2. server接收到信息之后给予client响应握手信息，包括随机值2和匹配好的协商加密算法，这个加密算法一定是client发送给server加密算法的子集。
3. 随即server给client发送第二个响应报文是数字证书。服务端必须要有一套数字证书，可以自己制作，也可以向组织申请。区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面，这套证书其实就是一对公钥和私钥。传送证书，这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间、服务端的公钥，第三方证书认证机构(CA)的签名，服务端的域名信息等内容。
4. 客户端解析证书，这部分工作是由客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。如果证书没有问题，那么就生成一个随即值（预主秘钥）。
5. 客户端认证证书通过之后，接下来是通过随机值1、随机值2和预主秘钥组装会话秘钥。然后通过证书的公钥加密会话秘钥。
6. 传送加密信息，这部分传送的是用证书加密后的会话秘钥，目的就是让服务端使用秘钥解密得到随机值1、随机值2和预主秘钥。
7. 服务端解密得到随机值1、随机值2和预主秘钥，然后组装会话秘钥，跟客户端会话秘钥相同。
8. 客户端通过会话秘钥加密一条消息发送给服务端，主要验证服务端是否正常接受客户端加密的消息。
9. 同样服务端也会通过会话秘钥加密一条消息回传给客户端，如果客户端能够正常接受的话表明SSL层连接建立完成了。

#### TLS（Transport Layer Security，安全传输层)

TLS是建立在传输层TCP协议之上的协议，服务于应用层，它的前身是SSL（Secure Socket Layer，安全套接字层），它实现了将应用层的报文进行加密后再交由TCP进行传输的功能。

1. SSL(Secure Sockets Layer 安全套接层),及其继任者传输层安全（Transport Layer Security，TLS）是为网络通信提供安全及数据完整性的一种安全协议。TLS与SSL在传输层对网络连接进行加密。
2. SSL协议位于TCP/IP协议与各种应用层协议之间，为数据通讯提供安全支持。SSL协议可分为两层： SSL记录协议（SSL Record Protocol）：它建立在可靠的传输协议（如TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能的支持。 SSL握手协议（SSL Handshake Protocol）：它建立在SSL记录协议之上，用于在实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等。
3. 安全传输层协议（TLS）用于在两个通信应用程序之间提供保密性和数据完整性。该协议由两层组成： TLS 记录协议（TLS Record）和 TLS 握手协议（TLS Handshake）。
4. TLS 的最大优势就在于：TLS 是独立于应用协议。高层协议可以透明地分布在 TLS 协议上面。然而，TLS 标准并没有规定应用程序如何在 TLS 上增加安全性；它把如何启动 TLS 握手协议以及如何解释交换的认证证书的决定权留给协议的设计者和实施者来判断。

#### HTTP 的方法有哪些

客户端发送的请求报文第一行为请求行，包含了方法字段。

1. `GET`
获取资源，当前网络中绝大部分使用的都是 GET；
2. `HEAD`
获取报文首部，和 GET 方法类似，但是不返回报文实体主体部分；
3. `POST`
传输实体，提交数据进行处理请求
4. `PUT`
上传文件，由于自身不带验证机制，任何人都可以上传文件，因此存在安全性问题，一般不使用该方法。
5. `PATCH`
对资源进行部分修改。PUT 也可以用于修改资源，但是只能完全替代原始资源，PATCH 允许部分修改。
6. `OPTIONS`
查询指定的 URL 支持的方法.
7. `CONNECT`
要求在与代理服务器通信时建立隧道。使用 SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。
8. `TRACE`
追踪路径。服务器会将通信路径返回给客户端。发送请求时，在 Max-Forwards 首部字段中填入数值，每经过一个服务器就会减 1，当数值为 0 时就停止传输。通常不会使用 TRACE，并且它容易受到 XST 攻击（Cross-Site Tracing，跨站追踪）
9. `DELETE`
请求服务器删除指定的页面

#### GET 和 POST 区别

1. get 是获取数据，post 一般用来更新服务器上的资源
2. get 把请求的数据放在 url 上， 以 ? 分割 URL 和传输数据，参数之间以 & 相连，所以get不太安全。而 post 把数据放在HTTP的包体内（requrest body）
3. GET **是幂等的**，即读取同一个资源，总是得到相同的数据，而 POST **不是幂等的**，因为每次请求对资源的改变并不是相同的
4. get提交的数据最大是2k（ 限制实际上取决于浏览器）， post理论上没有限制。
5. **GET 产生一个TCP数据包也就是一次请求**，浏览器会把 `http header` 和 `data` 一并发送出去，服务器响应 200(返回数据); **POST 产生两个 TCP 数据包**，浏览器先发送header，服务器响应 `100 continue`，浏览器再发送 data，服务器响应200 ok(返回数据)。
6. GET请求会被浏览器主动缓存，而POST不会，除非手动设置。

**本质区别**：GET 只是一次 HTTP请求，POST 先发请求头再发请求体，实际上是两次请求。

#### HTTP状态码

- 200：请求成功
- 300：针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。
- 301：永久重定向，资源被永久转移到其他URI，会返回新的URI，今后新请求应使用新URI
- 302：临时重定向，客户端应继续使用原有URI
- 304：所请求的资源未修改，服务器不返回任何资源
- 400：Bad Request,请求有语法问题 
- 401：用户身份验证未提供或未通过
- 403：服务器拒绝执行此请求
- 404：请求的资源不存在、
- 499: 客户关闭连接 `499, client has closed connection`。proxy_ignore_client_abort on; //  Don’t know if this is safe.
- 500：内部服务器错误
- 501：服务器不具备完成请求的功能。例如无法识别请求方法时可能返回。
- 502：bad Gateway
- 503：service unavailable服务不可用
- 504: Gateway Timeout 网关超时。
  - fastcgi_connect_timeout、fastcgi_send_timeout、fastcgi_read_timeout、fastcgi_buffer_size、fastcgi_buffers、fastcgi_busy_buffers_size、fastcgi_temp_file_write_size、fastcgi_intercept_errors。特别是前三个超时时间。如果fastcgi缓冲区太小会导致fastcgi进程被挂起从而演变为504错误。

#### 影响http最大连接数的因素

**系统用一个4元组来唯一标识一个TCP连接**：`{local ip, local port,remote ip,remote port}`。

1. **进程限制**
执行 `ulimit -n` 输出 1024，说明对于一个进程而言最多只能打开1024个文件，所以你要采用此默认配置最多也就可以并发上千个TCP连接。临时修改：`ulimit -n 1000000`，但是这种临时修改只对当前登录用户目前的使用环境有效，系统重启或用户退出后就会失效。
2. **client最大tcp连接数**
client 每次发起 tcp 连接请求时，除非绑定端口，通常会让系统选取一个空闲的本地端口（local port），该端口是独占的，不能和其他 tcp 连接共享。tcp 端口的数据类型是 unsigned short(2字节)，因此本地端口个数最大只有65536，端口0有特殊含义，不能使用，这样可用端口最多只有65535，所以在全部作为 client 端的情况下，最大 tcp 连接数为65535，这些连接可以连到不同的server ip。
3. **server最大tcp连接数**
server 通常固定在某个本地端口上监听，等待 client 的连接请求。不考虑地址重用（unix的SO_REUSEADDR选项）的情况下，即使server 端有多个 ip，本地监听端口也是独占的，因此 server 端 tcp 连接4元组中只有 remote ip（client ip）和 remote port（client port）是可变的，因此最大 tcp 连接为客户端ip数×客户端port数，对IPV4，不考虑ip地址分类等因素，最大tcp连接数约为2的32次方（ip数）×2的16次方（port数），也就是server端单机最大tcp连接数约为2的48次方。
4. **端口号范围限制**
操作系统上端口号1024以下是系统保留的，从1024-65535是用户使用的。对于有一个机器，如果只有一个IP地址，并且连接全部作为client，由于每个TCP连接都要占一个端口号，所以最多可以有60000多个并发连接

### 浏览器输入网址到显示主页的过程

1. **DNS 域名解析**
浏览器查询 DNS，获取域名对应的 IP 地址：具体过程包括浏览器搜索自身的 DNS 缓存、搜索操作系统的 DNS 缓存、读取本地的 Host 文件和向本地 DNS 服务器进行查询等。对于向本地 DNS 服务器进行查询，如果要查询的域名包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析(此解析具有权威性)；如果要查询的域名不由本地 DNS 服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个 IP 地址映射，完成域名解析（此解析不具有权威性）。如果本地域名服务器并未缓存该网址映射关系，那么将根据其设置发起递归查询或者迭代查询
2. **TCP 连接**
浏览器获得域名对应的 IP 地址以后，浏览器向服务器请求建立链接，发起三次握手
3. **发送 HTTP 请求**
经过三次握手成功建立连接后，开始传送数据，如果是 http 协议的话，就返回就完事了
如果不是http协议，服务器会返回一个5开头的的重定向消息，告诉我们用的是https，那就是说IP没变，但是端口号从80变成443了，好了，再四次挥手，完事，再来一遍，这次除了上述的端口号从80变成443之外，还会采用SSL的加密技术来保证传输数据的安全性，保证数据传输过程中不被修改或者替换之类的
4. **服务器处理请求并返回 HTTP 报文**
服务器接收到这个请求，并根据路径参数映射到特定的请求处理器进行处理，并将处理结果及相应的视图返回给浏览器
5. **浏览器解析渲染页面**
浏览器解析并渲染视图，若遇到对 js 文件、css 文件及图片等静态资源的引用，则重复上述步骤并向服务器请求这些资源；浏览器根据其请求到的资源、数据渲染页面，最终向用户呈现一个完整的页面
6. **连接结束**

### DNS

`DNS`（Domain Name System，域名系统），**因特网上作为域名和IP地址相互映射的一个分布式数据库**，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串

#### 域名的结构

`www.tmall.com` 对应的真正的域名为 `www.tmall.com.`。

- **根域名**
末尾的 `.` 称为**根域名**，因为每个域名都有根域名，因此通常省略。
- **顶级域名**
根域名的下一级，叫做 **顶级域名**，比如 `.com`、`.net`；
- **次级域名**
再下一级叫做 **次级域名**，比如 `www.tmall.com` 里面的 `.tmall`，这一级域名是用户可以注册的；
- **主机名**
再下一级是 **主机名**（host），比如 `www.tmall.com` 里面的 `www`，又称为"三级域名"，这是用户在自己的域里面为服务器分配的名称，是用户可以任意分配的。

#### DNS域名系统工作原理

总结： 浏览器缓存，系统缓存，路由器缓存，IPS服务器缓存，根域名服务器缓存，顶级域名服务器缓存，主域名服务器缓存。
一、主机向本地域名服务器的查询一般都是采用递归查询
二、本地域名服务器向根域名服务器的查询的迭代查询

1. 当用户输入域名时，浏览器先检查自己的缓存中是否有这个域名映射的ip地址，有解析结束
2. 若没命中，则检查操作系统缓存（如Windows的hosts）中有没有解析过的结果，有解析结束
3. 若无命中，则请求本地域名服务器解析（ LDNS）
4. 若LDNS没有命中就直接跳到根域名服务器请求解析。根域名服务器返回给LDNS一个主域名服务器地址。
5. 此时LDNS再发送请求给上一步返回的gTLD（ 通用顶级域），接受请求的gTLD查找并返回这个域名对应的Name Server的地址
6. Name Server根据映射关系表找到目标ip，返回给LDNS
7. LDNS缓存这个域名和对应的ip， 把解析的结果返回给用户，用户根据TTL值缓存到本地系统缓存中，域名解析过程至此结束

#### 为什么域名解析用UDP协议?

因为UDP快啊！**UDP 的 DNS 协议只要一个请求、一个应答就好了**。
而使用基于TCP的DNS协议要三次握手、发送数据以及应答、四次挥手。但是 UDP 协议传输内容不能超过512字节。不过客户端向DNS服务器查询域名，一般返回的内容都不超过512字节，用 UDP 传输即可。

#### 为什么区域传送用TCP协议？

因为 TCP 协议可靠性好啊！你要从主 DNS 上复制内容啊，你用不可靠的 UDP？ 因为 TCP 协议传输的内容大啊，你用最大只能传512字节的UDP协议？万一同步的数据大于512字节，你怎么办？

#### 区域传输

**将一个区域文件复制到多个 DNS 服务器的过程**。
通过从主服务器上将区域文件的信息复制到辅助服务器来实现,当主服务器的区域有变化时，该变化会通过区域传输机制

#### CNAME有什么好处？也就是别名

方便cdn配置？
CDN 的定义：CDN 就是采用更多的缓存服务器（CDN边缘节点），布放在用户访问相对集中的地区或网络中。当用户访问网站时，利用全局负载技术，将用户的访问指向距离最近的缓存服务器上，由缓存服务器响应用户请求。

#### DNS 负载均衡

当一个网站有足够多的用户的时候，假如每次请求的资源都位于同一台机器上面，那么这台机器随时可能会蹦掉。
处理办法就是用 DNS 负载均衡技术，**它的原理是在 DNS 服务器中为同一个主机名配置多个 IP 地址,在应答 DNS 查询时,DNS 服务器对每个查询将以 DNS 文件中主机记录的 I P地址按顺序返回不同的解析结果,将客户端的访问引导到不同的机器上去,使得不同的客户端访问不同的服务器**,从而达到负载均衡的目的｡
例如可以根据每台机器的负载量，该机器离用户地理位置的距离等等。

### 谈谈你对域名缓存的了解？

为了提高 DNS 查询效率，并减轻服务器的负荷和减少因特网上的 DNS 查询报文数量，在域名服务器中广泛使用了高速缓存，用来存放最近查询过的域名以及从何处获得域名映射信息的记录。
由于名字到地址的绑定并不经常改变，为保持高速缓存中的内容正确，域名服务器应为每项内容设置计时器并处理超过合理时间的项（例如：每个项目两天）。当域名服务器已从缓存中删去某项信息后又被请求查询该项信息，就必须重新到授权管理该项的域名服务器绑定信息。当权限服务器回答一个查询请求时，在响应中都指明绑定有效存在的时间值。增加此时间值可减少网络开销，而减少此时间值可提高域名解析的正确性。
不仅在本地域名服务器中需要高速缓存，在主机中也需要。许多主机在启动时从本地服务器下载名字和地址的全部数据库，维护存放自己最近使用的域名的高速缓存，并且只在从缓存中找不到名字时才使用域名服务器。维护本地域名服务器数据库的主机应当定期地检查域名服务器以获取新的映射信息，而且主机必须从缓存中删除无效的项。由于域名改动并不频繁，大多数网点不需花精力就能维护数据库的一致性。

## OSI 模型

**OSI分层（7层）**：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层
**TCP/IP分层（4层）**：网络接口层、网际层、运输层、应用层
**五层协议（5层）**：物理层、数据链路层、网络层、运输层、应用层

### 分层介绍

1. **应用层**
应用层（application-layer）的任务是通过应用进程间的交互来完成特定网络应用。应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则。对于不同的网络应用需要不同的应用层协议。
在互联网中应用层协议很多，如域名系统 DNS，支持万维网应用的 HTTP 协议，支持电子邮件的 SMTP 协议等等。我们把应用层交互的数据单元称为报文。
`HTTP-超文本传输协议、FTP-文件传输、SMTP-邮件传输协议、DNS-域名系统、SSH-安全外壳协议`

2. **会话层**
控制应用程序之间会话能力；如不同软件数据分发给不同软件。

3. **表示层**
数据格式标识，基本压缩加密功能。

4. **传输层**
运输层（transport layer）的主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务。应用进程利用该服务传送应用层报文。“通用的”是指并不针对某一个特定的网络应用，而是多种应用可以使用同一个运输层服务。
由于一台主机可同时运行多个线程，因此运输层有复用和分用的功能。所谓复用就是指多个应用层进程可同时使用下面运输层的服务，分用和复用相反，是运输层把收到的信息分别交付上面应用层中的相应进程。
`TCP-传输控制协议、UDP-用户数据报文协议`

5. **网络层**
在计算机网络中进行通信的两个计算机之间可能会经过很多个数据链路，也可能还要经过很多通信子网。网络层的任务就是选择合适的网间路由和交换结点，确保数据及时传送。在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。
在 `TCP / IP` 体系结构中，由于网络层使用 IP 协议，因此分组也叫 IP 数据报，简称数据报。
`IP-网际协议、ARP-地址转换协议、RIP-路由信息协议`

6. **数据链路层**
数据链路层（data link layer）通常简称为链路层。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如：同步信息，地址信息，差错控制等）。
在接收数据时，控制信息使接收端能够知道一个帧从哪个比特开始和到哪个比特结束。这样，数据链路层在收到一个帧后，就可从中提出数据部分，上交给网络层。控制信息还使接收端能够检测到所收到的帧中有无差错。如果发现差错，数据链路层就简单地丢弃这个出了差错的帧，以避免继续在网络中传送下去白白浪费网络资源。如果需要改正数据在链路层传输时出现差错（这就是说，数据链路层不仅要检错，而且还要纠错），那么就要采用可靠性传输协议来纠正出现的差错。这种方法会使链路层的协议复杂些。
`ARQ-自动重传协议、PPP-点对点协议`

7. **物理层**
在物理层上所传送的数据单位是比特。物理层（physical layer）的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。使其上面的数据链路层不必考虑网络的具体传输介质是什么。“透明传送比特流”表示经实际电路传送后的比特流没有发生变化，对传送的比特流来说，这个电路好像是看不见的。
`中继器、集线器`

## TCP/UDP

### TCP特点

1. **TCP 是面向连接的**（
就好像打电话一样，通话前需要先拨号建立连接，通话结束后要挂机释放连接）
2. **TCP 点对点**
每一条 TCP 连接只能有两个端点，每一条 TCP 连接只能是**点对点的（一对一）**
3. **TCP 提供可靠交付的服务**
通过 TCP 连接传送的数据，无差错、不丢失、不重复、并且按序到达；
4. **TCP 提供全双工通信**
TCP 允许通信双方的应用进程在任何时候都能发送数据。TCP 连接的两端都设有发送缓存和接收缓存，用来临时存放双方通信的数据；
5. **面向字节流**
TCP 中的“流”（Stream）指的是流入进程或从进程流出的字节序列。
**面向字节流的含义是**：虽然应用程序和 TCP 的交互是一次一个数据块（大小不等），但 TCP 把应用程序交下来的数据仅仅看成是一连串的无结构的字节流。

### UDP特点

1. **UDP 是无连接的**
2. **UDP 不保证可靠交付**，使用尽最大努力交付，因此主机不需要维持复杂的链接状态（这里面有许多参数）
3. **UDP 是面向报文的**(面向报文的传输方式是应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文。因此，应用程序必须选择合适大小的报文)
4. **UDP 没有拥塞控制**，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如直播，实时视频会议等）
5. **UDP 支持一对一、一对多、多对一和多对多的交互通信**
6. **UDP 的首部开销小**，只有 8 个字节，比 TCP 的 20 个字节的首部要短

### TCP

#### TCP 粘包/拆包

一个完整的业务可能会被TCP拆分成多个包进行发送，也有可能把多个小的包封装成一个大的数据包发送，这个就是TCP的拆包和粘包问题

1. TCP 是基于字节流的，虽然应用层和 TCP 传输层之间的数据交互是大小不等的数据块，但是 TCP 把这些数据块仅仅看成一连串无结构的字节流，没有边界；
2. 从 TCP 的帧结构也可以看出，在 TCP 的首部没有表示数据长度的字段。
基于上面两点，在使用 TCP 传输数据时，才有粘包或者拆包现象发生的可能。一个数据包中包含了发送端发送的两个数据包的信息，这种现象即为粘包。
接收端收到了两个数据包，但是这两个数据包要么是不完整的，要么就是多出来一块，这种情况即发生了拆包和粘包。拆包和粘包的问题导致接收端在处理的时候会非常困难，因为无法区分一个完整的数据包。

#### TCP 黏包是怎么产生的？

1. 发送方产生粘包
采用 TCP 协议传输数据的客户端与服务器经常是保持一个长连接的状态（一次连接发一次数据不存在粘包），双方在连接不断开的情况下，可以一直传输数据。**但当发送的数据包过于的小时，那么 TCP 协议默认的会启用 Nagle 算法，将这些较小的数据包进行合并发送（缓冲区数据发送是一个堆压的过程）；这个合并过程就是在发送缓冲区中进行的，也就是说数据发送出来它已经是粘包的状态了**。
2. 接收方产生粘包
接收方采用 TCP 协议接收数据时的过程是这样的：数据到接收方，从网络模型的下方传递至传输层，传输层的 TCP 协议处理是将其放置接收缓冲区，然后由应用层来主动获取（C 语言用 recv、read 等函数）；这时会出现一个问题，就是我们在程序中调用的读取数据函数不能及时的把缓冲区中的数据拿出来，而下一个数据又到来并有一部分放入的缓冲区末尾，等我们读取数据时就是一个粘包。
**放数据的速度 > 应用层拿数据速度**

#### 粘包解决方案

1. 消息定长。
2. 在包尾部增加回车或者空格符等特殊字符进行分割
3. 将消息分为消息头和消息尾。
4. 使用其它复杂的协议，如RTMP协议等。

### UDP

#### 设计一个基于 UDP 的差不多可靠的算法

1. 数据完整性 –> 加上一个16或者32位的CRC验证字段
2. 乱序 –> 加上一个数据包序列号SEQ
3. 丢包 –> 需要确认和重传机制，就是和Tcp类似的Ack机制
4. 协议字段 –> protol 字段，标识当前使用协议



## 三次握手

## 四次挥手

### 3. QUIC

`QUIC`(Quick UDP Internet Connections，快速UDP互联网连接)是Google提出的一种基于UDP改进的通信协议，其目的是降低网络通信的延迟，提供更好的用户互动体验。

`QUIC` 的主要特点包括：具有 `SPDY` (SPDY是谷歌研制的提升HTTP速度的协议，是HTTP/2.0的基础)所有的优点；`

- 0-RTT` 连接
- 减少丢包
- 前向纠错，减少重传时延
- 自适应拥塞控制， 减少重新连接
- 相当于 TLS 加密

1. **0RTT快速连接**

    - TCP最少需要花费1RTT的时间来建立连接。
    - TLS1.2下，首次建立连接，首先需要1次RTT建立连接（蓝色线），2次RTT交换密钥和加密策略（黑色线），然后开始通信。再次建立连接时，由于已缓存了密钥，因此少1次RTT。
    - TLS1.3和QUIC都采用了Diffie-Hellman密钥交换算法来交换密钥。该算法的优点是交换密钥只需要1次RTT。
    在QUIC下，只有首次建立连接交换密钥时消耗1RTT时间，再次连接时就是0RTT了。这已最大限度的减少握手延迟带来的影响。这个特性在连接延迟较大的移动网络上有较好的性能提升。

2. **连接迁移**
TCP下一个连接是以四元组标识的，即（SrcIp，SrcPort，DstIp，DstPort）。而QUIC连接是以客户端产生的一个64位随机数作为连接标识。当网络、端口发生改变或中断时，只要连接标识不改变，连接就不会中断。

3. **改进拥塞控制**
QUIC在应用层即可实现不同的拥塞控制算法，不需要改操作系统和内核。
单个程序的不同连接也能支持配置不同的拥塞控制。这样我们就可以给不同的用户提供更好的拥塞控制。
应用程序变更拥塞控制，甚至不需要停机和升级。
QUIC还有带宽预测，RTT监控，发送速率调整等高级算法支持。
4. **双级别流控**
TCP通过滑动窗口机制来保证可靠性以及进行流量控制。QUIC更新了其滑动窗口机制，并在Connection和Stream两个级别分别进行流控。
用公式表示就是：
**connection可用窗口 = stream1可用窗口 + stream2可用窗口 + streamN可用窗口**

5. 没有队头阻塞的多路复用
SDPY 和 HTTP2 协议的多路复用，是让所有请求在一个TCP连接上传输。前面说过，TCP协议有队头阻塞问题，如果某个资源的某个包丢失了，由于TCP是保证时序的，就会在接收端形成队头阻塞。TCP协议无法区分各个资源的包是否关联，因此会停止处理所有资源，直到丢包恢复。

    QUIC 是基于 UDP 的，UDP 不需要保证包的时序，因而不存在等待丢包恢复，不存在队头阻塞问题。如果某个资源的某个包丢失了，只会影响单个资源，其他资源会继续传输。

6. **实现与升级更灵活**
TCP协议栈是写在操作系统内核以及中间设备固件上的，对其更新升级，耗费的时间是以年为周期。
基于UDP协议栈的QUIC协议在应用层实现。应用软件的更新较为轻量，因此协议新特性的升级迭代周期是以月或周来计算。

## 4. IP

### 4.x ICMP

### 4.x PING 命令
