# 4.0 语言基础

## 4.1 函数调用

### 4.1.2 参数传递

Go 语言选择了传值的方式，无论是传递基本类型、结构体还是指针，都会对传递的参数进行拷贝。

#### 整形和数组

```go
func myFunction(i int, arr [2]int) {
    fmt.Printf("in my_funciton - i=(%d, %p) arr=(%v, %p)\n", i, &i, arr, &arr)
}

func main() {
    i := 30
    arr := [2]int{66, 77}
    fmt.Printf("before calling - i=(%d, %p) arr=(%v, %p)\n", i, &i, arr, &arr)
    myFunction(i, arr)
    fmt.Printf("after  calling - i=(%d, %p) arr=(%v, %p)\n", i, &i, arr, &arr)
}

$ go run main.go
before calling - i=(30, 0xc00009a000) arr=([66 77], 0xc00009a010)
in my_funciton - i=(30, 0xc00009a008) arr=([66 77], 0xc00009a020)
after  calling - i=(30, 0xc00009a000) arr=([66 77], 0xc00009a010)
```

main 函数和被调用者 myFunction 中参数的地址是完全不同的。

如果我们在 myFunction 函数内部对参数进行修改是否会影响 main 函数中的变量呢？

```go
func myFunction(i int, arr [2]int) {
    i = 29
    arr[1] = 88
    fmt.Printf("in my_funciton - i=(%d, %p) arr=(%v, %p)\n", i, &i, arr, &arr)
}

$ go run main.go
before calling - i=(30, 0xc000072008) arr=([66 77], 0xc000072010)
in my_funciton - i=(29, 0xc000072028) arr=([66 88], 0xc000072040)
after  calling - i=(30, 0xc000072008) arr=([66 77], 0xc000072010)
```

我们可以看到在 myFunction 中对参数的修改也仅仅影响了当前函数，并没有影响调用方 main 函数，所以能得出如下结论：**Go 语言的整型和数组类型都是值传递的，也就是在调用函数时会对内容进行拷贝**。
*需要注意的是如果当前数组的大小非常的大，这种传值的方式会对性能造成**比较大的影响***。

#### 结构体和指针

```go
type MyStruct struct {
    i int
}

func myFunction(a MyStruct, b *MyStruct) {
    a.i = 31
    b.i = 41
    fmt.Printf("in my_function - a=(%d, %p) b=(%v, %p)\n", a, &a, b, &b)
}

func main() {
    a := MyStruct{i: 30}
    b := &MyStruct{i: 40}
    fmt.Printf("before calling - a=(%d, %p) b=(%v, %p)\n", a, &a, b, &b)
    myFunction(a, b)
    fmt.Printf("after calling  - a=(%d, %p) b=(%v, %p)\n", a, &a, b, &b)
}

$ go run main.go
before calling - a=({30}, 0xc000018178) b=(&{40}, 0xc00000c028)
in my_function - a=({31}, 0xc000018198) b=(&{41}, 0xc00000c038)
after calling  - a=({30}, 0xc000018178) b=(&{41}, 0xc00000c028)
```

上述运行的结果我们可以得出如下结论：

- **传递结构体时**：会拷贝结构体中的全部内容；
- **传递结构体指针时**：会拷贝结构体指针；

修改结构体指针是改变了指针指向的结构体，b.i 可以被理解成 (*b).i，也就是我们先获取指针 b 背后的结构体，再修改结构体的成员变量。

```go
type MyStruct struct {
    i int
    j int
}

func myFunction(ms *MyStruct) {
    ptr := unsafe.Pointer(ms)
    for i := 0; i < 2; i++ {
        c := (*int)(unsafe.Pointer((uintptr(ptr) + uintptr(8*i))))
        *c += i + 1
        fmt.Printf("[%p] %d\n", c, *c)
    }
}

func main() {
    a := &MyStruct{i: 40, j: 50}
    myFunction(a)
    fmt.Printf("[%p] %v\n", a, a)
}

$ go run main.go
[0xc000018180] 41
[0xc000018188] 52
[0xc000018180] &{41 52}
```

在这段代码中，**通过指针修改结构体中的成员变量，结构体在内存中是一片连续的空间，指向结构体的指针也是指向这个结构体的首地址**。将 MyStruct 指针修改成 int 类型的，那么访问新指针就会返回整型变量 i，将指针移动 8 个字节之后就能获取下一个成员变量 j。

将指针作为参数传入某个函数时，函数内部会复制指针，也就是会同时出现两个指针指向原有的内存空间，所以 Go 语言中传指针也是传值。

## 4.2 接口

### 4.2.1 概述

#### 隐式接口

定义接口需要使用 `interface` 关键字，在接口中我们只能定义方法签名，不能包含成员变量，一个常见的 Go 语言接口是这样的：

```go
type error interface {
    Error() string
}
```

如果一个类型需要实现 `error` 接口，那么它只需要实现 `Error() string` 方法，下面的 `RPCError` 结构体就是 `error` 接口的一个实现：

```go
type RPCError struct {
    Code    int64
    Message string
}

func (e *RPCError) Error() string {
    return fmt.Sprintf("%s, code=%d", e.Message, e.Code)
}
```

**Go 语言中接口的实现都是隐式的**，我们只需要实现 Error() string 方法就实现了 error 接口。Go 语言实现接口的方式与 Java 完全不同：

- 在 Java 中：实现接口需要显式地声明接口并实现所有方法；
- 在 Go 中：实现接口的所有方法就隐式地实现了接口；

```go
func main() {
    var rpcErr error = NewRPCError(400, "unknown err") // typecheck1
    err := AsErr(rpcErr) // typecheck2
    println(err)
}

func NewRPCError(code int64, msg string) error {
    return &RPCError{ // typecheck3
        Code:    code,
        Message: msg,
    }
}

func AsErr(err error) error {
    return err
}
```

Go 语言在编译期间对代码进行类型检查，上述代码总共触发了三次类型检查：

1. 将 `*RPCError` 类型的变量赋值给 error 类型的变量 rpcErr；
2. 将 `*RPCError` 类型的变量 rpcErr 传递给签名中参数类型为 error 的 AsErr 函数；
3. 将 `*RPCError` 类型的变量从函数签名的返回值类型为 error 的 NewRPCError 函数中返回；

#### 类型

接口也是 Go 语言中的一种类型，它能够出现在变量的定义、函数的入参和返回值中并对它们进行约束，不过 Go 语言中有两种略微不同的接口，一种是带有一组方法的接口，另一种是不带任何方法的 `interface{}`：

Go 语言使用 `runtime.iface` 表示包含方法的接口，使用 `runtime.eface` 表示第二种不包含任何方法的接口 `interface{}`，两种接口虽然都使用 `interface` 声明，但是由于后者在 Go 语言中很常见，所以在实现时使用了特殊的类型。

#### 指针和接口

```go
type Cat struct {}
type Duck interface { ... }

func (c  Cat) Quack {}  // 使用结构体实现接口
func (c *Cat) Quack {}  // 使用结构体指针实现接口

var d Duck = Cat{}      // 使用结构体初始化变量
var d Duck = &Cat{}     // 使用结构体指针初始化变量
```

对 Cat 结构体来说，它在实现接口时可以选择接受者的类型，即结构体或者结构体指针，在初始化时也可以初始化成结构体或者指针。下面的代码总结了如何使用结构体、结构体指针实现接口，以及如何使用结构体、结构体指针初始化变量。

```go
type Cat struct{}

func (c Cat) Quack() {
    fmt.Println("meow")
}

func main() {
    var c Duck = &Cat{}
    c.Quack()
}
```

作为指针的 `&Cat{}` 变量能够隐式地获取到指向的结构体，所以能在结构体上调用 `Walk` 和 `Quack` 方法。我们可以将这里的调用理解成 C 语言中的 `d->Walk()` 和 `d->Speak()`，它们都会先获取指向的结构体再执行对应的方法。

```go
type Duck interface {
    Quack()
}

type Cat struct{}

func (c *Cat) Quack() {
    fmt.Println("meow")
}

func main() {
    var c Duck = Cat{}
    c.Quack()
}

$ go build interface.go
./interface.go:20:6: cannot use Cat literal (type Cat) as type Duck in assignment:
    Cat does not implement Duck (Quack method has pointer receiver)
```

无论上述代码中初始化的变量 c 是 `Cat{}` 还是 `&Cat{}`，使用 `c.Quack()` 调用方法时都会发生值拷贝：

- 对于 `&Cat{}` 来说，这意味着拷贝一个新的 `&Cat{}` 指针，这个指针与原来的指针指向一个相同并且唯一的结构体，所以编译器可以隐式的对变量解引用（dereference）获取指针指向的结构体；
- 对于 `Cat{}` 来说，这意味着 Quack 方法会接受一个全新的 `Cat{}`，因为方法的参数是 `*Cat`，编译器不会无中生有创建一个新的指针；即使编译器可以创建新指针，这个指针指向的也不是最初调用该方法的结构体；

#### nil 和 non-nil

我们可以通过一个例子理解 Go 语言的接口类型不是任意类型这一句话，下面的代码在 main 函数中初始化了一个 `*TestStruct` 类型的变量，由于指针的零值是 nil，所以变量 s 在初始化之后也是 nil：

```go
package main

type TestStruct struct{}

func NilOrNot(v interface{}) bool {
    return v == nil
}

func main() {
    var s *TestStruct
    fmt.Println(s == nil)      // #=> true
    fmt.Println(NilOrNot(s))   // #=> false
}

$ go run main.go
true
false
```

- 将上述变量与 nil 比较会返回 true；
- 将上述变量传入 NilOrNot 方法并与 nil 比较会返回 false；

### 4.2.2 数据结构

- 使用 `runtime.iface` 结构体表示包含方法的接口
- 使用 `runtime.eface` 结构体表示不包含任何方法的 interface{} 类型；

```go
// 不包含任何方法
type eface struct { // 16 字节
    _type *_type
    data  unsafe.Pointer
}

// 包含方法
type iface struct { // 16 字节
    tab  *itab
    data unsafe.Pointer
}
```

#### 类型结构体

`runtime._type` 是 Go 语言类型的运行时表示。下面是运行时包中的结构体，其中包含了很多类型的元信息，例如：类型的大小、哈希、对齐以及种类等。

```go
type _type struct {
    size       uintptr
    ptrdata    uintptr
    hash       uint32
    tflag      tflag
    align      uint8
    fieldAlign uint8
    kind       uint8
    equal      func(unsafe.Pointer, unsafe.Pointer) bool
    gcdata     *byte
    str        nameOff
    ptrToThis  typeOff
}
```

- `size` 字段存储了类型占用的内存空间，为内存空间的分配提供信息；
- `hash` 字段能够帮助我们快速确定类型是否相等；
- `equal` 字段用于判断当前类型的多个对象是否相等，该字段是为了减少 Go 语言二进制包大小从 typeAlg 结构体中迁移过来的；

#### itab 结构体

`runtime.itab` 结构体是接口类型的核心组成部分，每一个 `runtime.itab` 都占 32 字节，我们可以将其看成接口类型和具体类型的组合，它们分别用 `inter` 和 `_type` 两个字段表示：

```go
type itab struct { // 32 字节
    inter *interfacetype
    _type *_type
    hash  uint32
    _     [4]byte
    fun   [1]uintptr
}
```

- **`hash` 是对 `_type.hash` 的拷贝**，当我们想将 `interface` 类型转换成具体类型时，可以使用该字段快速判断目标类型和具体类型 `runtime._type` 是否一致；
- **`fun` 是一个动态大小的数组，它是一个用于动态派发的虚函数表，存储了一组函数指针**。虽然该变量被声明成大小固定的数组，但是在使用时会通过原始指针获取其中的数据，所以 `fun` 数组中保存的元素数量是不确定的；

### 4.2.3 类型转换

## 4.3 反射

### 4.3.1 三大法则

#### 第一法则

反射的第一法则是我们能将 Go 语言的 interface{} 变量转换成反射对象。
当我们执行 `reflect.ValueOf(1)` 时，虽然看起来是获取了基本类型 int 对应的反射类型，**但是由于 `reflect.TypeOf`、`reflect.ValueOf` 两个方法的入参都是 `interface{}` 类型，所以在方法执行的过程中发生了类型转换**。

#### 第二法则

反射的第二法则是我们可以从反射对象可以获取 interface{} 变量。
既然能够将接口类型的变量转换成反射对象，那么一定需要其他方法将反射对象还原成接口类型的变量，reflect 中的 `reflect.Value.Interface` 就能完成这项工作。
不过调用 `reflect.Value.Interface` 方法只能获得 `interface{}` 类型的变量，如果想要将其还原成最原始的状态还需要经过如下所示的显式类型转换：

```go
v := reflect.ValueOf(1)
v.Interface().(int)
```

从反射对象到接口值的过程是从接口值到反射对象的镜面过程，两个过程都需要经历两次转换：

- 从接口值到反射对象：
  - 从基本类型到接口类型的类型转换；
  - 从接口类型到反射对象的转换；
- 从反射对象到接口值：
  - 反射对象转换成接口类型；
  - 通过显式类型转换变成原始类型；

#### 第三法则

第三法则是与值是否可以被更改有关，如果我们想要修改一个 `reflect.Value` ，那么它持有的值一定是可以被更新的。

```go
func main() {
    i := 1
    v := reflect.ValueOf(i)
    v.SetInt(10)
    fmt.Println(i)
}

$ go run reflect.go
panic: reflect: reflect.flag.mustBeAssignable using unaddressable value
```

**由于 Go 语言的函数调用都是传值的，所以我们得到的反射对象跟最开始的变量没有任何关系**，那么直接修改反射对象无法改变原始变量，程序为了防止错误就会崩溃。

想要修改原变量只能用如下方法修改：

```go
func main() {
    i := 1
    v := reflect.ValueOf(&i)
    v.Elem().SetInt(10)
    fmt.Println(i)
}

$ go run reflect.go
10
```

1. 调用 `reflect.ValueOf` 获取变量指针；
2. 调用 `reflect.Value.Elem` 获取指针指向的变量；
3. 调用 `reflect.Value.SetInt` 更新变量的值。

由于 Go 语言的函数调用都是值传递的，所以我们只能只能用迂回的方式改变原变量：先获取指针对应的 `reflect.Value`，再通过 `reflect.Value.Elem` 方法得到可以被设置的变量，我们可以通过下面的代码理解这个过程：

```go
func main() {
    i := 1
    v := &i
    *v = 10
}
```

**如果不能直接操作 i 变量修改其持有的值，我们就只能获取 i 变量所在地址并使用 `*v` 修改所在地址中存储的整数**。

### 4.3.2 类型和值

Go 语言的 `interface{}` 类型在语言内部是通过 `reflect.emptyInterface` 结体表示的，其中的 `rtype` 字段用于表示变量的类型，另一个 `word` 字段指向内部封装的数据：

```go
type emptyInterface struct {
    typ  *rtype
    word unsafe.Pointer
}
```

用于获取变量类型的 `reflect.TypeOf` 函数将传入的变量隐式转换成 `reflect.emptyInterface` 类型并获取其中存储的类型信息 `reflect.rtype`：

```go
func TypeOf(i interface{}) Type {
    eface := *(*emptyInterface)(unsafe.Pointer(&i))
    return toType(eface.typ)
}

func toType(t *rtype) Type {
    if t == nil {
        return nil
    }
    return t
}
```

`reflect.rtype` 是一个实现了 `reflect.Type` 接口的结构体，该结构体实现的 `reflect.rtype.String` 方法可以帮助我们获取当前类型的名称：

```go
func (t *rtype) String() string {
    s := t.nameOff(t.str).name()
    if t.tflag&tflagExtraStar != 0 {
        return s[1:]
    }
    return s
}
```

`reflect.TypeOf` 的实现原理其实并不复杂，它只是将一个 `interface{}` 变量转换成了内部的 `reflect.emptyInterface` 表示，然后从中获取相应的类型信息。

用于获取接口值 `reflect.Value` 的函数 `reflect.ValueOf` 实现也非常简单，在该函数中我们先调用了 `reflect.escapes` 保证当前值逃逸到堆上，然后通过 `reflect.unpackEface` 从接口中获取 `reflect.Value` 结构体：

```go
func ValueOf(i interface{}) Value {
    if i == nil {
        return Value{}
    }

    escapes(i)

    return unpackEface(i)
}

func unpackEface(i interface{}) Value {
    e := (*emptyInterface)(unsafe.Pointer(&i))
    t := e.typ
    if t == nil {
        return Value{}
    }
    f := flag(t.Kind())
    if ifaceIndir(t) {
        f |= flagIndir
    }
    return Value{t, e.word, f}
}
```

`reflect.unpackEface` 会将传入的接口转换成 `reflect.emptyInterface`，然后将具体类型和指针包装成 `reflect.Value` 结构体后返回。

### 4.3.3 更新变量

当我们想要更新 `reflect.Value` 时，就需要调用 `reflect.Value.Set` 更新反射对象，该方法会调用 `reflect.flag.mustBeAssignable` 和 `reflect.flag.mustBeExported` 分别检查当前反射对象是否是可以被设置的以及字段是否是对外公开的：

```go
func (v Value) Set(x Value) {
    v.mustBeAssignable()
    x.mustBeExported()
    var target unsafe.Pointer
    if v.kind() == Interface {
        target = v.ptr
    }
    x = x.assignTo("reflect.Set", v.typ, target)
    typedmemmove(v.typ, v.ptr, x.ptr)
}
```

`reflect.Value.Set` 会调用 `reflect.Value.assignTo` 并返回一个新的反射对象，这个返回的反射对象指针会直接覆盖原反射变量。

```go
func (v Value) assignTo(context string, dst *rtype, target unsafe.Pointer) Value {
    ...
    switch {
    case directlyAssignable(dst, v.typ):
        ...
        return Value{dst, v.ptr, fl}
    case implements(dst, v.typ):
        if v.Kind() == Interface && v.IsNil() {
            return Value{dst, nil, flag(Interface)}
        }
        x := valueInterface(v, false)
        if dst.NumMethod() == 0 {
            *(*interface{})(target) = x
        } else {
            ifaceE2I(dst, x, target)
        }
        return Value{dst, target, flagIndir | flag(Interface)}
    }
    panic(context + ": value of type " + v.typ.String() + " is not assignable to type " + dst.String())
}
```

`reflect.Value.assignTo` 会根据当前和被设置的反射对象类型创建一个新的 `reflect.Value` 结构体：

- 如果两个反射对象的类型是可以被直接替换，就会直接返回目标反射对象；
- 如果当前反射对象是接口并且目标对象实现了接口，就会把目标对象简单包装成接口值；
在变量更新的过程中，`reflect.Value.assignTo` 返回的 `reflect.Value` 中的指针会覆盖当前反射对象中的指针实现变量的更新。

### 4.3.4 实现协议

假设需要判断如下代码中的 `CustomError` 是否实现了 Go 语言标准库中的 `error` 接口：

```go
type CustomError struct{}

func (*CustomError) Error() string {
    return ""
}

func main() {
    typeOfError := reflect.TypeOf((*error)(nil)).Elem()
    customErrorPtr := reflect.TypeOf(&CustomError{})
    customError := reflect.TypeOf(CustomError{})

    fmt.Println(customErrorPtr.Implements(typeOfError)) // #=> true
    fmt.Println(customError.Implements(typeOfError)) // #=> false
}
```

- `CustomError` 类型并没有实现 error 接口；
- `*CustomError` 指针类型实现了 error 接口；

### 4.3.5 方法调用

```go
func Add(a, b int) int { return a + b }

func main() {
    v := reflect.ValueOf(Add)
    if v.Kind() != reflect.Func {
        return
    }
    t := v.Type()
    argv := make([]reflect.Value, t.NumIn())
    for i := range argv {
        if t.In(i).Kind() != reflect.Int {
            return
        }
        argv[i] = reflect.ValueOf(i)
    }
    result := v.Call(argv)
    if len(result) != 1 || result[0].Kind() != reflect.Int {
        return
    }
    fmt.Println(result[0].Int()) // #=> 1
}
```

1. 通过 `reflect.ValueOf` 获取函数 `Add` 对应的反射对象；
2. 调用 `reflect.rtype.NumIn` 获取函数的入参个数；
3. 多次调用 `reflect.ValueOf` 函数逐一设置 `argv` 数组中的各个参数；
4. 调用反射对象 `Add` 的 `reflect.Value.Call` 方法并传入参数列表；
5. 获取返回值数组、验证数组的长度以及类型并打印其中的数据；

```go
func (v Value) Call(in []Value) []Value {
    v.mustBe(Func)
    v.mustBeExported()
    return v.call("Call", in)
}
Go
```

`reflect.Value.Call` 是运行时调用方法的入口，它通过两个 `MustBe` 开头的方法确定了当前反射对象的类型是函数以及可见性，随后调用 `reflect.Value.call` 完成方法调用，这个私有方法的执行过程会分成以下的几个部分：

1. 查输入参数以及类型的合法性；
2. 将传入的 `reflect.Value` 参数数组设置到栈上；
3. 通过函数指针和输入参数调用函数；
4. 从栈上获取函数的返回值；

#### 参数检查

参数检查是通过反射调用方法的第一步，在参数检查期间我们会从反射对象中取出当前的函数指针 `unsafe.Pointer`，如果该函数指针是方法，那么我们会通过 `reflect.methodReceiver` 获取方法的接收者和函数指针。

#### 参数准备

函数或者方法在调用时，所有的参数都会被依次放到栈上。

```go
    nout := t.NumOut()
    frametype, _, retOffset, _, framePool := funcLayout(t, rcvrtype)

    var args unsafe.Pointer
    if nout == 0 {
        args = framePool.Get().(unsafe.Pointer)
    } else {
        args = unsafe_New(frametype)
    }
    off := uintptr(0)
    if rcvrtype != nil {
        storeRcvr(rcvr, args)
        off = ptrSize
    }
    for i, v := range in {
        targ := t.In(i).(*rtype)
        a := uintptr(targ.align)
        off = (off + a - 1) &^ (a - 1)
        n := targ.size
        ...
        addr := add(args, off, "n > 0")
        v = v.assignTo("reflect.Value.Call", targ, addr)
        *(*unsafe.Pointer)(addr) = v.ptr
        off += n
    }
```

1. 通过 reflect.funcLayout 计算当前函数需要的参数和返回值的栈布局，也就是每一个参数和返回值所占的空间大小；
2. 如果当前函数有返回值，需要为当前函数的参数和返回值分配一片内存空间 args；
3. 如果当前函数是方法，需要向将方法的接收接收者者拷贝到 args 内存中；
4. 将所有函数的参数按照顺序依次拷贝到对应 args 内存中
   1. 使用 reflect.funcLayout 返回的参数计算参数在内存中的位置；
   2. 将参数拷贝到内存空间中；

准备参数是计算各个参数和返回值占用的内存空间并将所有的参数都拷贝内存空间对应位置的过程，该过程会考虑函数和方法、返回值数量以及参数类型带来的差异。

#### 调用函数

我们会向该函数传入栈类型、函数指针、参数和返回值的内存空间、栈的大小以及返回值的偏移量：

```go
    call(frametype, fn, args, uint32(frametype.size), uint32(retOffset))
```

#### 处理返回值

- 如果函数没有任何返回值，会直接清空 `args` 中的全部内容来释放内存空间；
- 如果当前函数有返回值；
    1. 将 `args` 中与输入参数有关的内存空间清空；
    2. 创建一个 `nout` 长度的切片用于保存由反射对象构成的返回值数组；
    3. 从函数对象中获取返回值的类型和内存大小，将 `args` 内存中的数据转换成 `reflect.Value` 类型并存储到切片中；

由 `reflect.Value` 构成的 `ret` 数组会被返回到调用方，到这里为止使用反射实现函数调用的过程就结束了。
