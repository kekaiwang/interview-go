# Golang

## string

### 编码

一个 bit 可以是 0 或者是 1，八个 bit 组成一个字节 byte，全是0 代表 0，全是 1 时代表 255，1 个字节代表 256 个数字，两个字节可以代表 65536 个数字。
给字母指定一个字符编号，读取时根据映射关系读取，像这样收录很多字符集并给他们一一编号，这就是字符集。

unicode 字符集通用字符集，跨语言跨平台的文本转换与处理，字符集促成了字符与二进制的合作。

主要的是划分字符边界。字符集配合编码。

定长编码和变长编码。

下面就是 UTF-8

```shell
编号                编码模版
[0, 127]            0??????
[128, 2047]         110???? 10??????
[2048, 65535]       1110??? 10?????? 10??????

// 例如 界
二进制：01110101 01001100
编码后：11100111 10010101 10001100
```

### go 字符串

C 语言字符结尾是使用特殊字符 `\0` 作为结尾。
go 语言在结构体里面加上了长度，是字节个数

```go
type StringHeader struct {
    Data uintptr // 起始地址
    Len  int
}
````

**因为字符串作为只读的类型，编译器会把字符串内容分配到只读内存段**，我们并不会直接向字符串直接追加元素改变其本身的内存空间，所有在字符串上的写入操作都是通过拷贝实现的。

字符串可以共用底层字符串内容的。可以把字符串强制修改为字节 slice 进行修改，这样会为 slice 变量重新分配一段内存并且会拷贝原来的字符串内容。

```go
    s1 := "kevin"
    bs := ([]byte)(s1)
    bs[2] = '0'
    fmt.Printf("%c\n", bs[2])
```

## slice 切片

### 数据结构

```go
type SliceHeader struct {
    Data uintptr
    Len  int
    Cap  int
}
```

- Data 是指向数组的指针;
- Len 是当前切片的长度；
- Cap 是当前切片的容量，即 Data 数组的大小可以存多少元素

#### 初始化切片

```go
    arr := arr[1:3]             // 下标
    arr := []int{1, 2, 3}       // 字面量
    arr := make([]int, 2, 3)    // 关键字
```

1. **使用下标初始化切片**不会拷贝原数组或者原切片中的数据，它只会创建一个指向原数组的切片结构体，所以修改新切片的数据也会修改原切片。
2. **字面量初始化切片**是在编译时完成的。
    1. 根据切片中的元素数量对底层数组的大小进行推断并创建一个数组
    2. 将这些字面量元素存储到初始化的数组中
    3. 创建一个同样指向 [3]int 类型的数组指针
    4. 将静态存储区的数组 vstat 赋值给 vauto 指针所在的地址
    5. 通过 [:] 操作获取一个底层使用 vauto 的切片
3. **关键字**创建切片时，很多工作都需要运行时的参与。不仅会检查 len 是否传入，还会保证传入的容量 cap 一定大于或者等于 len。

当切片发生逃逸或者非常大时，运行时需要 runtime.makeslice 在堆上初始化切片，如果当前的切片不会发生逃逸并且切片非常小的时候，会直接使用下标得到得到数组对应的切片。

##### 整形切片

```go
var ints []int
```

slice 的元素要存在连续的内存中，也就是连续数组。 `data` 是底层数组的起始地址,这里只分配了切片结构没有分配底层数组，此时 `data = nil`，`Len 和 Cap` 都为零。

```go
var arr []int = make([]int, 2, 5)
arr = append(arr, 1)
arr[0] = 1
```

通过 `make` 的方式定义变量，不仅会分配结构还会开辟一段内存作为它的底层数组。此时分配的值都为 0。通过 `append` 之后此时索引 2 的位置被修改为 1，通过索引下标 0 修改后第一个元素为 1， 其他位置还是默认值 0。

##### 字符串类型切片

```go
arr := new([]string)

*arr = append(*arr, "kevin")
// append(arr, "kevin") 会报错 
// invalid argument: arr (variable of type *[]string) is not a slicecompiler
// 因为 new 返回的是指针起始地址
```

上面 `new` 一个 slice 对象同样会分配切片的三部分，它不负责底层数组的分配，new 的返回值是 slice 的指针地址，如果这时候 `(*arr)[0] = "kevin"` 通过下标修改切片内容是不允许的，此时可以通过 append 进行分配底层数组。

##### 和字符串相关的底层数组

底层数组是相同类型的元素一个挨一个的存储，不同的slice 可以关联到同一个数组。slice 的 data 起始指针并不一定指向数组的开头，如下例：

```go
arr := [10]int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}

var s1 = arr[1:4]
var s2 = arr[7:]
```

s1 的元素是 arr 索引 1到4 的元素，**左闭又开**，长度是 3，但是容量 `Cap` 是从索引 1 开始到末尾 为 9，s2 的元素是从 索引 7 到末尾，总共三个元素容量 Cap 也是 3。slice 访问和修改的都是底层数组的元素。

```go
s1[3] = 5
```

上面 s1 就会越界产生 panic，只能扩大读写区间范围。
此时如果给 s2 添加元素 `s2 = append(s2, 10)` 会开辟新数组，原来的元素要拷过来同时添加新元素，元素个数改为 4，容量扩到 6。

### 扩容规则

如果 `append` 返回的*新切片不需要赋值回原有的变量*，就会 `makeslice` 创建一个新的 slice；如果使用 `slice = append(slice, 1, 2, 3)` 语句，那么 `append` 后的切片会覆盖原切片。

```go
// append(slice, 1, 2, 3)
ptr, len, cap := slice
newlen := len + 3
if newlen > cap {
    ...
}
*(ptr+len) = 1
*(ptr+len+1) = 2
*(ptr+len+2) = 3
return makeslice(ptr, newlen, cap)

// slice = append(slice, 1, 2, 3)
a := &slice
... // 同上
if uint(newlen) > uint(cap) {
   *a.cap = newcap
   *a.ptr = newptr
}
newlen = len + 3
*a.len = newlen
*(ptr+len) = 1
*(ptr+len+1) = 2
*(ptr+len+2) = 3
```

#### 预估容量

```go
arr := []int{1, 2}
arr = append(arr, 3, 4, 5)
```

上面扩容后容量到 5，因为整形元素占有 8 字节，根据内存规格匹配到 48 。下面分析为什么？

在分配内存空间之前需要先确定新的切片容量，运行时根据切片的当前容量选择不同的策略进行扩容：

1. 如果期望容量大于当前容量的两倍就会使用期望容量
2. 如果当前切片的长度小于 1024 就会将容量翻倍
3. 如果当前切片的长度大于 1024 就会每次增加 25% 的容量，直到新容量大于期望容量

#### 内存分配

**内存空间=切片中元素大小×目标容量**。

语言的内存管理模块会提前向操作系统申请一批内存，分成常用规格管理起来。当申请内存时会匹配合适的规格进行分配。

```go
var class_to_size = [_NumSizeClasses]uint16{
    0,
    8,
    16,
    32,
    48,
    64,
    80,
    ...,
}
```

例子如下：

```go
a := []string{"my", "name", "is"}
a = append(a, "kevin")
```

1. 字符串在 64 位机器上每个元素占 16 字节，扩容前容量是 3，添加一个最少扩容到4，原容量翻倍等于 6 大于 4，小于1024，直接翻倍预估容量为 6。
2. 预估容量\*元素大小（6*16=96byte）
3. 匹配到内存规格 96 所以最终扩容后容量为 6
