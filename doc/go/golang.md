# Golang

[toc]

## 1. string

### 编码

一个 bit 可以是 0 或者是 1，八个 bit 组成一个字节 byte，全是0 代表 0，全是 1 时代表 255，1 个字节代表 256 个数字，两个字节可以代表 65536 个数字。
给字母指定一个字符编号，读取时根据映射关系读取，像这样收录很多字符集并给他们一一编号，这就是字符集。

unicode 字符集通用字符集，跨语言跨平台的文本转换与处理，字符集促成了字符与二进制的合作。

主要的是划分字符边界。字符集配合编码。

定长编码和变长编码。

下面就是 UTF-8

```shell
编号                编码模版
[0, 127]            0??????
[128, 2047]         110???? 10??????
[2048, 65535]       1110??? 10?????? 10??????

// 例如 界
二进制：01110101 01001100
编码后：11100111 10010101 10001100
```

### go 字符串

C 语言字符结尾是使用特殊字符 `\0` 作为结尾。
**go 语言在结构体里面加上了长度，是字节个数**

```go
type StringHeader struct {
    Data uintptr // 起始地址
    Len  int
}
````

**因为字符串作为只读的类型，编译器会把字符串内容分配到只读内存段**，我们并不会直接向字符串直接追加元素改变其本身的内存空间，所有在字符串上的写入操作都是通过拷贝实现的。

字符串可以共用底层字符串内容的。可以把字符串强制修改为字节 slice 进行修改，这样会为 slice 变量重新分配一段内存并且会拷贝原来的字符串内容。

```go
    s1 := "kevin"
    bs := ([]byte)(s1)
    bs[2] = '0'
    fmt.Printf("%c\n", bs[2])
```

## 2. slice 切片

### 数据结构

```go
type SliceHeader struct {
    Data uintptr
    Len  int
    Cap  int
}
```

- Data 是指向数组的指针;
- Len 是当前切片的长度；
- Cap 是当前切片的容量，即 Data 数组的大小可以存多少元素

#### 初始化切片

```go
    arr := arr[1:3]             // 下标
    arr := []int{1, 2, 3}       // 字面量
    arr := make([]int, 2, 3)    // 关键字
```

1. **使用下标初始化切片**不会拷贝原数组或者原切片中的数据，它只会创建一个指向原数组的切片结构体，所以修改新切片的数据也会修改原切片。
2. **字面量初始化切片**是在编译时完成的。
    1. 根据切片中的元素数量对底层数组的大小进行推断并创建一个数组
    2. 将这些字面量元素存储到初始化的数组中
    3. 创建一个同样指向 [3]int 类型的数组指针
    4. 将静态存储区的数组 vstat 赋值给 vauto 指针所在的地址
    5. 通过 [:] 操作获取一个底层使用 vauto 的切片
3. **关键字**创建切片时，很多工作都需要运行时的参与。不仅会检查 len 是否传入，还会保证传入的容量 cap 一定大于或者等于 len。

当切片发生逃逸或者非常大时，运行时需要 runtime.makeslice 在堆上初始化切片，如果当前的切片不会发生逃逸并且切片非常小的时候，会直接使用下标得到得到数组对应的切片。

##### 整形切片

```go
var ints []int
```

slice 的元素要存在连续的内存中，也就是连续数组。 `data` 是底层数组的起始地址,这里只分配了切片结构没有分配底层数组，此时 `data = nil`，`Len 和 Cap` 都为零。

```go
var arr []int = make([]int, 2, 5)
arr = append(arr, 1)
arr[0] = 1
```

**通过 `make` 的方式定义变量，不仅会分配结构还会开辟一段内存作为它的底层数组**。此时分配的值都为 0。通过 `append` 之后此时索引 2 的位置被修改为 1，通过索引下标 0 修改后第一个元素为 1， 其他位置还是默认值 0。

##### 字符串类型切片

```go
arr := new([]string)

*arr = append(*arr, "kevin")
// append(arr, "kevin") 会报错 
// invalid argument: arr (variable of type *[]string) is not a slicecompiler
// 因为 new 返回的是指针起始地址
```

上面 `new` 一个 slice 对象同样会分配切片的三部分，它不负责底层数组的分配，new 的返回值是 slice 的指针地址，如果这时候 `(*arr)[0] = "kevin"` 通过下标修改切片内容是不允许的，此时可以通过 append 进行分配底层数组。

##### 和字符串相关的底层数组

底层数组是相同类型的元素一个挨一个的存储，不同的slice 可以关联到同一个数组。slice 的 data 起始指针并不一定指向数组的开头，如下例：

```go
arr := [10]int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}

var s1 = arr[1:4]
var s2 = arr[7:]
```

s1 的元素是 arr 索引 1到4 的元素，**左闭又开**，长度是 3，但是容量 `Cap` 是从索引 1 开始到末尾 为 9，s2 的元素是从 索引 7 到末尾，总共三个元素容量 Cap 也是 3。slice 访问和修改的都是底层数组的元素。

```go
s1[3] = 5
```

上面 s1 就会越界产生 panic，只能扩大读写区间范围。
此时如果给 s2 添加元素 `s2 = append(s2, 10)` 会开辟新数组，原来的元素要拷过来同时添加新元素，元素个数改为 4，容量扩到 6。

### 扩容规则

如果 `append` 返回的*新切片不需要赋值回原有的变量*，就会 `makeslice` 创建一个新的 slice；如果使用 `slice = append(slice, 1, 2, 3)` 语句，那么 `append` 后的切片会覆盖原切片。

```go
// append(slice, 1, 2, 3)
ptr, len, cap := slice
newlen := len + 3
if newlen > cap {
    ...
}
*(ptr+len) = 1
*(ptr+len+1) = 2
*(ptr+len+2) = 3
return makeslice(ptr, newlen, cap)

// slice = append(slice, 1, 2, 3)
a := &slice
... // 同上
if uint(newlen) > uint(cap) {
   *a.cap = newcap
   *a.ptr = newptr
}
newlen = len + 3
*a.len = newlen
*(ptr+len) = 1
*(ptr+len+1) = 2
*(ptr+len+2) = 3
```

#### 预估容量

```go
arr := []int{1, 2}
arr = append(arr, 3, 4, 5)
```

上面扩容后容量到 5，因为整形元素占有 8 字节，根据内存规格匹配到 48 。下面分析为什么？

在分配内存空间之前需要先确定新的切片容量，运行时根据切片的当前容量选择不同的策略进行扩容：

1. 如果期望容量大于当前容量的两倍就会使用期望容量
2. 如果当前切片的长度小于 1024 就会将容量翻倍
3. 如果当前切片的长度大于 1024 就会每次增加 25% 的容量，直到新容量大于期望容量

#### 内存分配

**内存空间=切片中元素大小×目标容量**。

语言的内存管理模块会提前向操作系统申请一批内存，分成常用规格管理起来。当申请内存时会匹配合适的规格进行分配。

```go
var class_to_size = [_NumSizeClasses]uint16{
    0,
    8,
    16,
    32,
    48,
    64,
    80,
    ...,
}
```

例子如下：

```go
a := []string{"my", "name", "is"}
a = append(a, "kevin")
```

1. 字符串在 64 位机器上每个元素占 16 字节，扩容前容量是 3，添加一个最少扩容到4，原容量翻倍等于 6 大于 4，小于1024，直接翻倍预估容量为 6。
2. 预估容量\*元素大小（6*16=96byte）
3. 匹配到内存规格 96 所以最终扩容后容量为 6

### 切片 copy

无论是编译期间拷贝还是运行时拷贝，两种拷贝方式都会通过 `runtime.memmove` 将整块内存的内容拷贝到目标的内存区域中。

## 3. 内存对齐

典型的内存布局是一个内存条一个面是一个 rank，一个 rank 有八个 chip，一个 chip 包含八个 Bank，到这里可以通过选择行和列来定位一个地址了。这不像我们逻辑上认为的那样存在，他们共用同一个地址各自选择同一个位置到字节再组合起来作为我们逻辑上认为的连续八个字节。若果使用这种设计这里的地址就只能是八的倍数。

之所以 CPU 能访问任意地址是因为他多做了一些处理，错格的地址分两次访问然后拼接返回。

**内存对其要求的数据存储地址以及占用的字节数都要是对齐边界的倍数**。

32 位平台上指针宽度和寄存器宽度都是 4 字节，64 位平台上都是 8 字节。被GO语言成为寄存器宽度的这个值就可以理解为机器字长，也是平台的最大对其边界。

```go
type A struct
    a int8      // 1 byte
    b int64     // 8 byte
    c int32     // 4 byte
    d int16     // 2 byte
}
```

取对齐边界的最大值 8 字节。**结构体整体占用字节数需要是对齐边界的倍数**。

![image](https://mail.wangkekai.cn/IMG_A119DAEA7C87-1.jpeg)

## 4. map 哈希表

### 设计原理

哈希函数的选择在很大程度上能够决定哈希表的读写性能。在理想情况下，哈希函数应该能够将不同键映射到不同的索引上，这要求哈希函数的输出范围大于输入范围，但是由于键的数量会远远大于映射的范围，所以在实际使用时，这个理想的效果是不可能实现的。

如果使用结果分布较为均匀的哈希函数，那么哈希的增删改查的时间复杂度为 𝑂(1)；但是如果哈希函数的结果分布不均匀，那么所有操作的时间复杂度可能会达到 𝑂(𝑛)，由此看来，使用好的哈希函数是至关重要的。

#### hash 桶选择

1. 取模法 hash%m
2. 与运算 hash&(m-1)

#### hash冲突

1. 开放寻址法
依次探测和比较数组中的元素以判断目标键值对是否存在于哈希表中
开放寻址法中对性能影响最大的是**装载因子**，它是数组中元素的数量与数组大小的比值。
2. 拉链法
实现拉链法一般会**使用数组加上链表**，不过一些编程语言会在拉链法的哈希中引入红黑树以优化性能，拉链法会使用链表数组作为哈希底层的数据结构。

**装载因子:=元素数量÷桶数量**。

### hash结构与初始化

```go
type hmap struct {
    count     int
    flags     uint8
    B         uint8
    noverflow uint16
    hash0     uint32

    buckets    unsafe.Pointer
    oldbuckets unsafe.Pointer
    nevacuate  uintptr

    extra *mapextra
}

type mapextra struct {
    overflow    *[]*bmap    // 已经使用的溢出桶
    oldoverflow *[]*bmap
    nextOverflow *bmap      // 下个空闲溢出桶
}
```

1. `count` 表示当前哈希表中的元素数量；
2. `B` 表示当前哈希表持有的 `buckets` 数量，但是因为哈希表中桶的数量都 2 的倍数，所以该字段会存储对数，也就是 `len(buckets) == 2^B`；
3. `hash0` 是哈希的种子，它能为哈希函数的结果引入随机性，这个值在创建哈希表时确定，并在调用哈希函数时作为参数传入；
4. `oldbuckets` 是**哈希在扩容时用于保存之前 buckets 的字段**，它的大小是当前 `buckets` 的一半；
5. `nevacuate` 哈希扩容时迁移的进度，也就是下一个要迁移的位置
6. `extra` 溢出桶的相关信息

#### bmap

桶的结构体 `runtime.bmap` 在 Go 语言源代码中的定义只包含一个简单的 `tophash` 字段，`tophash` 存储了键的哈希的高 8 位，通过比较不同键的哈希的高 8 位可以减少访问键值对次数以提高性能

每一个 `runtime.bmap` 都能存储 8 个键值对，为了让内存更加紧凑，8个 key 放一起，8个 value 放一起，他们前面就是 `tophash`。
当哈希表中存储的数据过多，单个桶已经装满时就会使用 `extra.nextOverflow` 中桶存储溢出的数据。

上述两种不同的桶在内存中是连续存储的，我们在这里将它们分别称为正常桶和溢出桶，上半部分的 `runtime.bmap` 就是正常桶，下面的 `runtime.bmap` 是溢出桶，溢出桶是在 Go 语言还使用 C 语言实现时使用的设计3，由于它**能够减少扩容的频率**所以一直使用至今。

#### 字面量初始化

```go
hash := map[string]int{
    "1": 2,
    "3": 4,
    "5": 6,
}
```

1. 当哈希表中的元素数量少于或者等于 25 个时，编译器会将字面量初始化的结构体将所有的键值对一次加入到哈希表中。
2. 一旦哈希表中元素的数量超过了 25 个，编译器会创建两个数组分别存储键和值，这些键值对会通过如下所示的 for 循环加入哈希

```go
hash := make(map[string]int, 26)
vstatk := []string{"1", "2", "3", ... ， "26"}
vstatv := []int{1, 2, 3, ... , 26}
for i := 0; i < len(vstak); i++ {
    hash[vstatk[i]] = vstatv[i]
}
```

#### 运行时初始化

当创建的哈希被分配到栈上并且其容量小于 `BUCKETSIZE = 8` 时，Go 语言在编译阶段会使用如下方式快速初始化哈希，这也是编译器对小容量的哈希做的优化。

1. 计算哈希占用的内存是否溢出或者超出能分配的最大值
2. 调用 `runtime.fastrand` 获取一个随机的哈希种子
3. 根据传入的 `hint` 计算出需要的最小需要的桶的数量
4. 使用 `runtime.makeBucketArray` 创建用于保存桶的数组

#### 读写操作

增加和修改字段都使用索引和赋值语句，而**删除字典中的数据需要使用关键字 `delete`**

```go
v     := hash[key] // => v     := *mapaccess1(maptype, hash, &key)
v, ok := hash[key] // => v, ok := mapaccess2(maptype, hash, &key)
```

- 当接受一个参数时，会使用 `runtime.mapaccess1`，该函数仅会返回一个指向目标值的指针；
- 当接受两个参数时，会使用 `runtime.mapaccess2`，除了返回目标值之外，它还会返回一个用于表示当前键对应的值是否存在的 bool 值

每一个桶都是一整片的内存空间，当发现桶中的 `tophash` 与传入键的 `tophash` 匹配之后，我们会通过指针和偏移量获取哈希中存储的键 `keys[0]` 并与 `key` 比较，如果两者相同就会获取目标值的指针 v`alues[0]` 并返回。

#### 扩容

`runtime.mapassign` 函数会在以下两种情况发生时触发哈希的扩容：

1. 装载因子已经超过 6.5
2. 哈希使用了太多溢出桶

如果这次扩容是溢出的桶太多导致的，那么这次扩容就是**等量扩容** `sameSizeGrow`，`sameSizeGrow` 是一种特殊情况下发生的扩容，当我们持续向哈希中插入数据并将它们全部删除时，如果哈希表中的数据量没有超过阈值，就会不断积累溢出桶造成缓慢的内存泄漏,引入了 sameSizeGrow 通过复用已有的哈希扩容机制解决该问题，一旦哈希中出现了过多的溢出桶，它会创建新桶保存数据，垃圾回收会清理老的溢出桶并释放内存。

#### 删除

如果想要删除哈希中的元素，就需要使用 Go 语言中的 `delete` 关键字，这个关键字的唯一作用就是将某一个键对应的元素从哈希表中删除，无论是该键对应的值是否存在，这个内建的函数都不会返回任何的结果。

哈希表的删除逻辑与写入逻辑很相似，只是触发哈希的删除需要使用关键字，*如果在删除期间遇到了哈希表的扩容，就会分流桶中的元素，分流结束之后会找到桶中的目标元素完成键值对的删除工作*。

Go 语言使用拉链法来解决哈希碰撞的问题实现了哈希表，**访问、写入和删除等操作都在编译期间转换成了运行时的函数或者方法**。哈希在每一个桶中存储键对应哈希的前 8 位，当对哈希进行操作时，这些 `tophash` 就成为可以帮助哈希快速遍历桶中元素的缓存。

哈希表的每个桶都只能存储 8 个键值对，一旦当前哈希的某个桶超出 8 个，新的键值对就会存储到哈希的溢出桶中。随着键值对数量的增加，溢出桶的数量和哈希的装载因子也会逐渐升高，超过一定范围就会触发扩容，扩容会将桶的数量翻倍，元素再分配的过程也是在调用写操作时增量进行的，不会造成性能的瞬时巨大抖动。

## 5. 函数调用

代码被编译器编译成机器指令放入可执行文件，执行时可执行文件被加载到内存中，机器指令对应到虚拟地址空间中，位于代码段。
函数调用另一个函数就会生成一条 call 指令，就会跳转到被调用函数的入口处开始执行，每个函数的最后都有一条 ret 指令在程序执行完成后跳转回调用处。
执行时需要足够的内存空间用于存放局部变量、参数、返回值等，对应到虚拟地址中的栈空间。

### 栈

![image](https://mail.wangkekai.cn/IMG_052EFB6072B2-1.jpeg)

运行时栈上面是**高地址，向下增长**，分配给函数的栈空间成为**函数栈帧**，栈底成为**栈基**(bp)，栈顶成为**栈指针**(sp)，被调用者是通过**栈指针加偏移**来定位到每个参数和返回值的。

go 是一次分配足够栈空间，避免栈越界。函数栈帧的大小可以在编译时确定对于栈消耗较大的函数 go 编译器会在函数头部插入检测代码，如果发现需要栈增长，就会另外分配更大空间并拷贝原内容。

### 参数传递和返回值

- **传值**：函数调用时会对参数进行拷贝，被调用方和调用方两者持有不相关的两份数据；
- **传引用**：函数调用时会传递参数的指针，被调用方和调用方两者持有相同的数据，任意一方做出的修改都会影响另一方。

**Go 语言选择了传值的方式，无论是传递基本类型、结构体还是指针，都会对传递的参数进行拷贝**。

- **传递结构体时**：会拷贝结构体中的全部内容；
- **传递结构体指针时**：会拷贝结构体指针；被调用者修改结构体会修改指针指向的结构体本身

#### 交换值

```go
func main() {
    a, b := 1, 2
    swap(a, b)
    fmt.Println(a, b) // 1, 2
}

func swap(a, b int) {
    a, b = b, a
}
```

![image](https://mail.wangkekai.cn/1640065918522.jpg)

修改为指针传递

```go
func main() {
    a, b := 1, 2
    swap(&a, &b)
    fmt.Println(a, b) // 2, 1
}

func swap(a, b *int) {
    *a, *b = *b, *a
}
```

![image](https://mail.wangkekai.cn/1640066185499.jpg)

上面交换的是参数地址的数据所以交换成功了

#### 有返回值情况

##### 匿名返回值的情况

![image](https://mail.wangkekai.cn/1640066587665.jpg)

栈分配时返回值在参数前分配，函数执行完成时先 return 将返回值复制到返回值空间，再执行 defer 函数。

##### 命名返回值的情况

![image](https://mail.wangkekai.cn/1640066754204.jpg)

**总结**。

1. 通过堆栈传递参数，**入栈的顺序是从右到左**，而*参数的计算是从左到右*；
2. 函数返回值通过堆栈传递并由调用者预先分配内存空间
3. 调用函数时都是传值，接收方会对入参进行复制再计算

## 6. 方法（函数）

go 语言中方法是头等公民，可以作为参数传递、可以做返回值也可以绑定到变量，go 语言成这样的参数、返回值或变量为 `function value`。`function value` 本质上是一个指针，但是并不直接指向函数指令入口而是志向 `runtime.funcval` 结构体，fn 是这个函数指令的入口。

```go
type funcval strcut {
    fn uintptr
}
```

![image](https://mail.wangkekai.cn/1640067251139.jpg)

**为什么要使用 `funcval` 结构体包装这个地址，通过二级指针调用呢？主要是为了处理闭包的情况**。

> 闭包就是能够读取其他函数内部变量的函数。例如在javascript中，只有函数内部的子函数才能读取局部变量，所以闭包可以理解成“定义在一个函数内部的函数“。在本质上，闭包是将函数内部和函数外部连接起来的桥梁。

闭包内使用的外部变量成为**捕获变量**。

![image](https://mail.wangkekai.cn/1640067787604.jpg)

c 没有被修改过，直接拷贝值到捕获列表就可以了。

![image](https://mail.wangkekai.cn/1640067906574.jpg)

**闭包导致局部变量堆分配，变量逃逸的一种场景**。

如果捕获的是参数，那么会在堆上分配，然后外层函数和闭包函数都是用堆上的这一个。
如果捕获的是返回值，调用者栈上也会分配返回值空间，闭包的外层函数也会在堆上分配一个，外层函数和闭包都使用堆上这一个，在外层函数返回前需要把堆上的返回值拷贝到栈上的返回值空间。

go 语言中函数类型只与参数和返回值相关。

指针接收者
![image](https://mail.wangkekai.cn/1640068479286.jpg)

## 7. defer

`defer` 在函数返回前倒序执行。先注册后执行。

`deferproc` 把需要执行的指令保存起来，称为 `defer` 注册。先注册后调用实现了延迟调用的结果。

`defer` 信息会注册一链表，当前执行的 `goroutine` 持有这个连表的头指针，每个 `goroutine` 在运行时都有一个对应的结构体 `g`，其中 \_defer 指向 defer 链表头，defer 链表链起来一个一个的 _defer 结构体，新注册的 defer 会添加到链表头，执行时也是从头开始，所以 defer 才会表现为倒序执行。

没有捕获列表的 function value 在编译阶段会做出优化，就是在只读数据段分配一个公用的 funcval 结构体。

## panic

## 8. 类型系统

## interface

一个变量要想赋值给一个非空接口，必须要实现接口的全部方法。
