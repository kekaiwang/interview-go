# 5.0 常用关键字

## 5.1 for 和 range

### 5.1.1 现象

#### 循环永动机

```go
func main() {
    arr := []int{1, 2, 3}
    for _, v := range arr {
        arr = append(arr, v)
    }
    fmt.Println(arr)
}

$ go run main.go
1 2 3 1 2 3
```

上述代码的输出意味着循环只遍历了原始切片中的三个元素，我们在遍历切片时追加的元素不会增加循环的执行次数，所以循环最终还是停了下来。

#### 神奇的指针

```go
func main() {
    arr := []int{1, 2, 3}
    newArr := []*int{}
    for _, v := range arr {
        newArr = append(newArr, &v)
    }
    for _, v := range newArr {
        fmt.Println(*v)
    }
}

$ go run main.go
3 3 3
```

正确的做法应该是使用 `&arr[i]` 替代 `&v`。

#### 遍历清空数组

```go
func main() {
    arr := []int{1, 2, 3}
    for i, _ := range arr {
        arr[i] = 0
    }
}
```

依次遍历切片和哈希看起来是非常耗费性能的，因为数组、切片和哈希占用的内存空间都是连续的，所以最快的方法是直接清空这片内存中的内容。

#### 随机遍历

```go
func main() {
    hash := map[string]int{
        "1": 1,
        "2": 2,
        "3": 3,
    }
    for k, v := range hash {
        println(k, v)
    }
}
```

**Go 语言在运行时为哈希表的遍历引入了不确定性**，也是告诉所有 Go 语言的使用者，程序不要依赖于哈希表的稳定遍历。

### 5.1.2 经典循环

Go 语言中的经典循环在编译器看来是一个 `OFOR` 类型的节点，这个节点由以下四个部分组成：

1. 初始化循环的 `Ninit`；
2. 循环的继续条件 `Left`；
3. 循环体结束时执行的 `Right`；
4. 循环体 `NBody`：

```go
for Ninit; Left; Right {
    NBody
}
```

一个常见的 `for` 循环代码会被 `cmd/compile/internal/gc.state.stmt` 转换成下面的控制结构，该结构中包含了 4 个不同的块，这些代码块之间的连接表示汇编语言中的跳转关系，与我们理解的 `for` 循环控制结构没有太多的差别。

![image](https://mail.wangkekai.cn/DF1A8464-B87F-4EEE-B4C2-01ADB7932FAF.png)

### 5.1.3 范围循环

与简单的经典循环相比，范围循环在 `Go` 语言中更常见、实现也更复杂。这种循环同时使用 `for` 和 `range` 两个关键字，**编译器会在编译期间将所有 `for-range` 循环变成经典循环**。

从编译器的视角来看，就是将 ORANGE 类型的节点转换成 OFOR 节点:

节点类型的转换过程都发生在中间代码生成阶段，所有的 `for-range` 循环都会被 `cmd/compile/internal/gc.walkrange` 转换成不包含复杂结构、只包含基本表达式的语句。接下来，我们按照循环遍历的元素类型依次介绍遍历数组和切片、哈希表、字符串以及管道时的过程。

#### 数组和切片

对于数组和切片来说，Go 语言有三种不同的遍历方式，这三种不同的遍历方式分别对应着代码中的不同条件，它们会在 `cmd/compile/internal/gc.walkrange` 函数中转换成不同的控制逻辑，我们会分成几种情况分析该函数的逻辑：

1. 分析遍历数组和切片清空元素的情况；
2. 分析使用 for range a {} 遍历数组和切片，不关心索引和数据的情况；
3. 分析使用 for i := range a {} 遍历数组和切片，只关心索引的情况；
4. 分析使用 for i, elem := range a {} 遍历数组和切片，关心索引和数据的情况

```go
func walkrange(n *Node) *Node {
    switch t.Etype {
    case TARRAY, TSLICE:
        if arrayClear(n, v1, v2, a) {
            return n
        }
```

`cmd/compile/internal/gc.arrayClear` 是一个非常有趣的优化，它会优化 Go 语言遍历数组或者切片并删除全部元素的逻辑：

```go
// 原代码
for i := range a {
    a[i] = zero
}

// 优化后
if len(a) != 0 {
    hp = &a[0]
    hn = len(a)*sizeof(elem(a))
    memclrNoHeapPointers(hp, hn)
    i = len(a) - 1
}
```

相比于依次清除数组或者切片中的数据，Go 语言会直接使用 `runtime.memclrNoHeapPointers` 或者 `runtime.memclrHasPointers` 清除目标数组内存空间中的全部数据，并在执行完成后更新遍历数组的索引，这也印证了我们在遍历清空数组一节中观察到的现象。

处理了这种特殊的情况之后，我们可以回到 `ORANGE` 节点的处理过程了。这里会设置 `for` 循环的 `Left` 和 `Right` 字段，也就是终止条件和循环体每次执行结束后运行的代码：

```go
        ha := a
        hv1 := temp(types.Types[TINT])
        hn := temp(types.Types[TINT])

        init = append(init, nod(OAS, hv1, nil))
        init = append(init, nod(OAS, hn, nod(OLEN, ha, nil)))

        n.Left = nod(OLT, hv1, hn)
        n.Right = nod(OAS, hv1, nod(OADD, hv1, nodintconst(1)))

        if v1 == nil {
            break
        }
```

如果循环是 `for range a {}`，那么就满足了上述代码中的条件 `v1 == nil`，即循环不关心数组的索引和数据，这种循环会被编译器转换成如下形式：

```go
ha := a
hv1 := 0
hn := len(ha)
v1 := hv1
for ; hv1 < hn; hv1++ {
    ...
}
```

这是 ORANGE 结构在编译期间被转换的最简单形式，*由于原代码不需要获取数组的索引和元素，只需要使用数组或者切片的数量执行对应次数的循环，所以会生成一个最简单的 for 循环*。

如果我们在遍历数组时需要使用索引 `for i := range a {}`，那么编译器会继续会执行下面的代码：

```go
        if v2 == nil {
            body = []*Node{nod(OAS, v1, hv1)}
            break
        }
```

`v2 == nil` 意味着调用方不关心数组的元素，只关心遍历数组使用的索引。它会将 `for i := range a {}` 转换成下面的逻辑，与第一种循环相比，这种循环在循环体中添加了 `v1 := hv1` 语句，传递遍历数组时的索引：

```go
    ha := a
    hv1 := 0
    hn := len(ha)
    v1 := hv1
    for ; hv1 < hn; hv1++ {
        v1 = hv1
        ...
    }
```

上面两种情况虽然也是使用 `range` 会经常遇到的情况，但是同时去遍历索引和元素也很常见。处理这种情况会使用下面这段的代码：

```go
        tmp := nod(OINDEX, ha, hv1)
        tmp.SetBounded(true)
        a := nod(OAS2, nil, nil)
        a.List.Set2(v1, v2)
        a.Rlist.Set2(hv1, tmp)
        body = []*Node{a}
    }
    n.Ninit.Append(init...)
    n.Nbody.Prepend(body...)

    return n
}
```

这段代码处理的使用者同时关心索引和切片的情况。它不仅会在循环体中插入更新索引的语句，还会插入赋值操作让循环体内部的代码能够访问数组中的元素：

```go
    ha := a
    hv1 := 0
    hn := len(ha)
    v1 := hv1
    v2 := nil
    for ; hv1 < hn; hv1++ {
        tmp := ha[hv1]
        v1, v2 = hv1, tmp
        ...
    }
```

**对于所有的 `range` 循环，Go 语言都会在编译期将原切片或者数组赋值给一个新变量 `ha`，在赋值的过程中就发生了拷贝，而我们又通过 `len` 关键字预先获取了切片的长度，所以在循环中追加新的元素也不会改变循环执行的次数，这也就解释了循环永动机一节提到的现象**。

而遇到这种同时遍历索引和元素的 `range` 循环时，Go 语言会额外创建一个新的 v2 变量存储切片中的元素，**循环中使用的这个变量 v2 会在每一次迭代被重新赋值而覆盖，赋值时也会触发拷贝**。

```go
    func main() {
        arr := []int{1, 2, 3}
        newArr := []*int{}
        for i, _ := range arr {
            newArr = append(newArr, &arr[i])
        }
        for _, v := range newArr {
            fmt.Println(*v)
        }
    }
```

因为在循环中获取返回变量的地址都完全相同，所以会发生神奇的指针一节中的现象。因此当我们想要访问数组中元素所在的地址时，不应该直接获取 `range` 返回的变量地址 `&v2`，而应该使用 `&a[index]` 这种形式。

#### 哈希表

在遍历哈希表时，编译器会使用 `runtime.mapiterinit` 和 `runtime.mapiternext` 两个运行时函数重写原始的 `for-range` 循环：

```go
    ha := a
    hit := hiter(n.Type)
    th := hit.Type
    mapiterinit(typename(t), ha, &hit)
    for ; hit.key != nil; mapiternext(&hit) {
        key := *hit.key
        val := *hit.val
    }
```

上述代码是展开 `for key, val := range hash {}` 后的结果，在 `cmd/compile/internal/gc.walkrange` 处理 `TMAP` 节点时，编译器会根据 `range` 返回值的数量在循环体中插入需要的赋值语句：

![image](https://mail.wangkekai.cn/DF0AD52B-E6B7-4CAD-96A7-B9A5FA6094D1.png)

这三种不同的情况分别向循环体插入了不同的赋值语句。遍历哈希表时会使用 `runtime.mapiterinit` 函数初始化遍历开始的元素：

```go
func mapiterinit(t *maptype, h *hmap, it *hiter) {
    it.t = t
    it.h = h
    it.B = h.B
    it.buckets = h.buckets

    r := uintptr(fastrand())
    it.startBucket = r & bucketMask(h.B)
    it.offset = uint8(r >> h.B & (bucketCnt - 1))
    it.bucket = it.startBucket
    mapiternext(it)
}
```

**该函数会初始化 `runtime.hiter` 结构体中的字段，并通过 `runtime.fastrand` 生成一个随机数帮助我们随机选择一个遍历桶的起始位置**。Go 团队在设计哈希表的遍历时就不想让使用者依赖固定的遍历顺序，所以引入了随机数保证遍历的随机性。

遍历哈希会使用 `runtime.mapiternext`，我们在这里简化了很多逻辑，省去了一些边界条件以及哈希表扩容时的兼容操作，这里只需要关注处理遍历逻辑的核心代码，我们会将该函数分成桶的选择和桶内元素的遍历两部分，首先是桶的选择过程：

```go
func mapiternext(it *hiter) {
    h := it.h
    t := it.t
    bucket := it.bucket
    b := it.bptr
    i := it.i
    alg := t.key.alg

next:
    if b == nil {
        if bucket == it.startBucket && it.wrapped {
            it.key = nil
            it.value = nil
            return
        }
        b = (*bmap)(add(it.buckets, bucket*uintptr(t.bucketsize)))
        bucket++
        if bucket == bucketShift(it.B) {
            bucket = 0
            it.wrapped = true
        }
        i = 0
    }
```

这段代码主要有两个作用：

1. 在待遍历的桶为空时，选择需要遍历的新桶；
2. 在不存在待遍历的桶时。返回 (nil, nil) 键值对并中止遍历；

#### 字符串

遍历字符串的过程与数组、切片和哈希表非常相似，只是在遍历时会获取字符串中索引对应的字节并将字节转换成 `rune`。我们在遍历字符串时拿到的值都是 `rune` 类型的变量，`for i, r := range s {}` 的结构都会被转换成如下所示的形式：

```go
ha := s
for hv1 := 0; hv1 < len(ha); {
    hv1t := hv1
    hv2 := rune(ha[hv1])
    if hv2 < utf8.RuneSelf {
        hv1++
    } else {
        hv2, hv1 = decoderune(ha, hv1)
    }
    v1, v2 = hv1t, hv2
}
```

在前面的字符串一节中我们曾经介绍过字符串是一个只读的字节数组切片，所以范围循环在编译期间生成的框架与切片非常类似，只是细节有一些不同。

使用下标访问字符串中的元素时得到的就是字节，但是这段代码会将当前的字节转换成 `rune` 类型。如果当前的 `rune` 是 `ASCII` 的，那么只会占用一个字节长度，每次循环体运行之后只需要将索引加一，但是如果当前 `rune` 占用了多个字节就会使用 `runtime.decoderune` 函数解码，具体的过程就不在这里详细介绍了。

#### 通道

一个形如 for v := range ch {} 的语句最终会被转换成如下的格式：

```go
ha := a
hv1, hb := <-ha
for ; hb != false; hv1, hb = <-ha {
    v1 := hv1
    hv1 = nil
    ...
}
```

该循环会使用 `<-ch` 从管道中取出等待处理的值，这个操作会调用 `runtime.chanrecv2` 并阻塞当前的协程，当 `runtime.chanrecv2` 返回时会根据布尔值 `hb` 判断当前的值是否存在：

1. 如果不存在当前值，意味着当前的管道已经被关闭；
2. 如果存在当前值，会为 `v1` 赋值并清除 `hv1` 变量中的数据，然后重新陷入阻塞等待新数据；

## 5.2 select

## 5.3 defer

使用 `defer` 的最常见场景是在函数调用结束后完成一些收尾工作，关闭文件描述符、关闭数据库连接以及解锁资源等。

### 5.3.1 现象

- `defer` 关键字的调用时机以及多次调用 `defer` 时执行顺序是如何确定的；
- `defer` 关键字使用传值的方式传递参数时会进行预计算，导致不符合预期的结果；

#### 作用域

```go
func main() {
    {
        defer fmt.Println("defer runs")
        fmt.Println("block ends")
    }
    
    fmt.Println("main ends")
}

$ go run main.go
block ends
main ends
defer runs
```

**`defer` *传入的函数不是在退出代码块的作用域时执行的，它只会在当前函数和方法返回之前被调用***。

#### 预计算参数

> Go 语言中所有的函数调用都是传值的，虽然 defer 是关键字，但是也继承了这个特性。

假设我们想计算 main 函数的运行时间

```go
func main() {
    startedAt := time.Now()

    defer fmt.Println(time.Since(startedAt))

    time.Sleep(time.Second)
}

$ go run main.go
0s
```

*我们会发现调用 `defer` 关键字会立刻拷贝函数中引用的外部参数，所以 `time.Since(startedAt)` 的结果不是在 main 函数退出之前计算的，而是在 `defer` 关键字调用时计算的，最终导致上述代码输出 0s*。

要想解决这个问题，我们需要向 `defer` 传入匿名函数：

```go
func main() {
    startedAt := time.Now()
    defer func() { fmt.Println(time.Since(startedAt)) }()

    time.Sleep(time.Second)
}

$ go run main.go
1s
```

**虽然调用 `defer` 关键字时也使用值传递，但是因为拷贝的是函数指针，所以 `time.Since(startedAt)` 会在 main 函数返回前调用并打印出符合预期的结果**。

### 5.3.2 数据结构

```go
type _defer struct {
    siz       int32
    started   bool
    openDefer bool
    sp        uintptr
    pc        uintptr
    fn        *funcval
    _panic    *_panic
    link      *_defer
}
```

`runtime._defer` 结构体是延迟调用链表上的一个元素，所有的结构体都会通过 `link` 字段串联成链表。

- `siz` 是参数和结果的内存大小；
- `sp` 和 `pc` 分别代表栈指针和调用方的程序计数器；
- `fn` 是 `defer` 关键字中传入的函数；
- `_panic` 是触发延迟调用的结构体，可能为空；
- `openDefer` 表示当前 `defer` 是否经过开放编码的优化；

### 5.3.3 执行机制

```go
func (s *state) stmt(n *Node) {
    ...
    switch n.Op {
    case ODEFER:
        if s.hasOpenDefers {
            s.openDeferRecord(n.Left) // 开放编码
        } else {
            d := callDefer // 堆分配
            if n.Esc == EscNever {
                d = callDeferStack // 栈分配
            }
            s.callResult(n.Left, d)
        }
    }
}
```

堆分配、栈分配和开放编码是处理 defer 关键字的三种方法，早期的 Go 语言会在堆上分配 `runtime._defer` 结构体，不过该实现的性能较差，Go 语言在 1.13 中引入栈上分配的结构体，减少了 30% 的额外开销1，并在 1.14 中引入了基于开放编码的 defer，使得该关键字的额外开销可以忽略不计2，我们在一节中会分别介绍三种不同类型 defer 的设计与实现原理。

### 5.3.4 堆上分配

根据 `cmd/compile/internal/gc.state.stmt` 方法对 `defer` 的处理我们可以看出，堆上分配的 `runtime._defer` 结构体是默认的兜底方案，当该方案被启用时，编译器会调用 `cmd/compile/internal/gc.state.callResult` 和 `cmd/compile/internal/gc.state.call`，这表示 `defer` 在编译器看来也是函数调用。

`cmd/compile/internal/gc.state.call` 会负责为所有函数和方法调用生成中间代码，它的工作包括以下内容：

1. 获取需要执行的函数名、闭包指针、代码指针和函数调用的接收方；
2. 获取栈地址并将函数或者方法的参数写入栈中；
3. 使用 `cmd/compile/internal/gc.state.newValue1A` 以及相关函数生成函数调用的中间代码；
4. 如果当前调用的函数是 `defer`，那么会单独生成相关的结束代码块；
5. 获取函数的返回值地址并结束当前调用；

```go
func (s *state) call(n *Node, k callKind, returnResultAddr bool) *ssa.Value {
    ...
    var call *ssa.Value
    if k == callDeferStack {
        // 在栈上初始化 defer 结构体
        ...
    } else {
        ...
        switch {
        case k == callDefer:
            aux := ssa.StaticAuxCall(deferproc, ACArgs, ACResults)
            call = s.newValue1A(ssa.OpStaticCall, types.TypeMem, aux, s.mem())
        ...
        }
        call.AuxInt = stksize
    }
    s.vars[&memVar] = call
    ...
}
```

defer 关键字在运行期间会调用 `runtime.deferproc`，这个函数**接收了参数的大小和闭包所在的地址两个参数**。

编译器不仅将 defer 关键字都转换成 `runtime.deferproc` 函数，它还会通过以下三个步骤为所有调用 defer 的函数末尾插入 `runtime.deferreturn` 的函数调用：

1. `cmd/compile/internal/gc.walkstmt` 在遇到 `ODEFER` 节点时会执行 `Curfn.Func.SetHasDefer(true)` 设置当前函数的 hasdefer 属性；
2. `cmd/compile/internal/gc.buildssa` 会执行 `s.hasdefer = fn.Func.HasDefer()` 更新 `state` 的 hasdefer；
3. `cmd/compile/internal/gc.state.exit` 会根据 `state` 的 `hasdefer` 在函数返回之前插入 `runtime.deferreturn` 的函数调用；

- `runtime.deferproc` 负责创建新的延迟调用；
- `runtime.deferreturn` 负责在函数调用结束时执行所有的延迟调用；

#### 创建延迟调用

`runtime.deferproc` 会为 `defer` 创建一个新的 `runtime._defer` 结构体、设置它的函数指针 fn、程序计数器 pc 和栈指针 sp 并将相关的参数拷贝到相邻的内存空间中：

```go
func deferproc(siz int32, fn *funcval) {
    sp := getcallersp()
    argp := uintptr(unsafe.Pointer(&fn)) + unsafe.Sizeof(fn)
    callerpc := getcallerpc()

    d := newdefer(siz)
    if d._panic != nil {
        throw("deferproc: d.panic != nil after newdefer")
    }
    d.fn = fn
    d.pc = callerpc
    d.sp = sp
    switch siz {
    case 0:
    case sys.PtrSize:
        *(*uintptr)(deferArgs(d)) = *(*uintptr)(unsafe.Pointer(argp))
    default:
        memmove(deferArgs(d), unsafe.Pointer(argp), uintptr(siz))
    }

    return0()
}
```

最后调用的 `runtime.return0` 是唯一一个不会触发延迟调用的函数，它可以避免递归 `runtime.deferreturn` 的递归调用。

`runtime.deferproc` 中 `runtime.newdefer` 的作用是想尽办法获得 `runtime._defer` 结构体，这里包含三种路径：

1. 从调度器的延迟调用缓存池 `sched.deferpool` 中取出结构体并将该结构体追加到当前 `Goroutine` 的缓存池中；
2. 从 `Goroutine` 的延迟调用缓存池 `pp.deferpool` 中取出结构体；
3. 通过 `runtime.mallocgc` 在堆上创建一个新的结构体；

无论使用哪种方式，只要获取到 `runtime._defer` 结构体，它都会被追加到所在 `Goroutine _defer` 链表的最前面。

**`defer` 关键字的插入顺序是从后向前的，而 `defer` 关键字执行是从前向后的，这也是为什么后调用的 `defer` 会优先执行。**

#### 执行延迟调用

`runtime.deferreturn` 会从 Goroutine 的 `_defer` 链表中取出最前面的 `runtime._defer` 并调用 `runtime.jmpdefer` 传入需要执行的函数和参数：

```go
func deferreturn(arg0 uintptr) {
    gp := getg()
    d := gp._defer
    if d == nil {
        return
    }
    sp := getcallersp()
    ...

    switch d.siz {
    case 0:
    case sys.PtrSize:
        *(*uintptr)(unsafe.Pointer(&arg0)) = *(*uintptr)(deferArgs(d))
    default:
        memmove(unsafe.Pointer(&arg0), deferArgs(d), uintptr(d.siz))
    }
    fn := d.fn
    gp._defer = d.link
    freedefer(d)
    jmpdefer(fn, uintptr(unsafe.Pointer(&arg0)))
}
```

`runtime.jmpdefer` 是一个用汇编语言实现的运行时函数，它的主要工作是跳转到 defer 所在的代码段并在执行结束之后跳转回 `runtime.deferreturn`。

```go
TEXT runtime·jmpdefer(SB), NOSPLIT, $0-8
    MOVL    fv+0(FP), DX    // fn
    MOVL    argp+4(FP), BX  // caller sp
    LEAL    -4(BX), SP  // caller sp after CALL
#ifdef GOBUILDMODE_shared
    SUBL    $16, (SP)   // return to CALL again
#else
    SUBL    $5, (SP)    // return to CALL again
#endif
    MOVL    0(DX), BX
    JMP BX  // but first run the deferred function
```

`runtime.deferreturn` 会多次判断当前 `Goroutine` 的 `_defer` 链表中是否有未执行的结构体，该函数只有在所有延迟函数都执行后才会返回。

### 5.3.5 栈上分配

在默认情况下， Go 语言中 `runtime._defer` 结构体都会在堆上分配，如果能够将部分结构体分配到栈上就可以节约内存分配带来的额外开销。

Go 语言团队在 1.13 中对 `defer` 关键字进行了优化，**当该关键字在函数体中最多执行一次时**，编译期间的 `cmd/compile/internal/gc.state.call` 会将结构体分配到栈上并调用 `runtime.deferprocStack`：

```go
func (s *state) call(n *Node, k callKind) *ssa.Value {
    ...
    var call *ssa.Value
    if k == callDeferStack {
        // 在栈上创建 _defer 结构体
        t := deferstruct(stksize)
        ...

        ACArgs = append(ACArgs, ssa.Param{Type: types.Types[TUINTPTR], Offset: int32(Ctxt.FixedFrameSize())})
        aux := ssa.StaticAuxCall(deferprocStack, ACArgs, ACResults) // 调用 deferprocStack
        arg0 := s.constOffPtrSP(types.Types[TUINTPTR], Ctxt.FixedFrameSize())
        s.store(types.Types[TUINTPTR], arg0, addr)
        call = s.newValue1A(ssa.OpStaticCall, types.TypeMem, aux, s.mem())
        call.AuxInt = stksize
    } else {
        ...
    }
    s.vars[&memVar] = call
    ...
}
```

**除了分配位置的不同，栈上分配和堆上分配的 `runtime._defer` 并没有本质的不同，而该方法可以适用于绝大多数的场景，与堆上分配的 `runtime._defer` 相比，该方法可以将 defer 关键字的额外开销降低 ~30%**。

### 5.3.5 开放编码

Go 语言在 1.14 中通过开放编码（Open Coded）实现 `defer` 关键字，该设计使用代码内联优化 `defer` 关键的额外开销并引入函数数据 `funcdata` 管理 `panic` 的调用，该优化可以将 `defer` 的调用开销从 1.13 版本的 ~35ns 降低至 ~6ns 左右：

然而开放编码作为一种优化 defer 关键字的方法，它不是在所有的场景下都会开启的，开放编码只会在满足以下的条件时启用：

1. 函数的 defer 数量少于或者等于 8 个；
2. 函数的 defer 关键字不能在循环中执行；
3. 函数的 return 语句与 defer 语句的乘积小于或者等于 15 个；

#### 启用优化

Go 语言会在编译期间就确定是否启用开放编码，在编译器生成中间代码之前，我们会使用 `cmd/compile/internal/gc.walkstmt` 修改已经生成的抽象语法树，设置函数体上的 `OpenCodedDeferDisallowed` 属性：

```go
const maxOpenDefers = 8

func walkstmt(n *Node) *Node {
    switch n.Op {
    case ODEFER:
        Curfn.Func.SetHasDefer(true)
        Curfn.Func.numDefers++
        if Curfn.Func.numDefers > maxOpenDefers {
            Curfn.Func.SetOpenCodedDeferDisallowed(true)
        }
        if n.Esc != EscNever {
            Curfn.Func.SetOpenCodedDeferDisallowed(true)
        }
        fallthrough
    ...
    }
}
```

如果函数中 defer 关键字的数量多于 8 个或者 `defer` 关键字处于 `for` 循环中，那么我们在这里都会禁用开放编码优化，使用上两节提到的方法处理 `defer`。

中间代码生成的这两个步骤会决定当前函数是否应该使用开放编码优化 defer 关键字，一旦确定使用开放编码，就会在编译期间初始化延迟比特和延迟记录。

#### 延迟记录

延迟比特和延迟记录是使用开放编码实现 `defer` 的两个最重要结构，一旦决定使用开放编码，`cmd/compile/internal/gc.buildssa` 会在编译期间在栈上初始化大小为 8 个比特的 `deferBits` 变量：

**延迟比特中的每一个比特位都表示该位对应的 `defer` 关键字是否需要被执行，其中 8 个比特的倒数第二个比特在函数返回前被设置成了 1，那么该比特位对应的函数会在函数返回前执行**

因为不是函数中所有的 `defer` 语句都会在函数返回前执行，如下所示的代码只会在 `if` 语句的条件为真时，其中的 `defer` 语句才会在结尾被执行

```go
deferBits := 0 // 初始化 deferBits

_f1, _a1 := f1, a1  // 保存函数以及参数
deferBits |= 1 << 0 // 将 deferBits 最后一位置位 1

if condition {
    _f2, _a2 := f2, a2  // 保存函数以及参数
    deferBits |= 1 << 1 // 将 deferBits 倒数第二位置位 1
}
exit:

if deferBits & 1 << 1 != 0 {
    deferBits &^= 1 << 1
    _f2(a2)
}

if deferBits & 1 << 0 != 0 {
    deferBits &^= 1 << 0
    _f1(a1)
}
```

延迟比特的作用就是标记哪些 `defer` 关键字在函数中被执行，这样在函数返回时可以根据对应 `deferBits` 的内容确定执行的函数，而正是因为 `deferBits` 的大小仅为 8 比特，所以该优化的启用条件为函数中的 `defer` 关键字少于 8 个。

## 5.4 panic 和 recover

- `panic` 能够改变程序的控制流，调用 `panic` 后会立刻停止执行当前函数的剩余代码，并在当前 `Goroutine` 中递归执行调用方的 `defer；`
- `recover` 可以中止 `panic` 造成的程序崩溃。它是一个只能在 `defer` 中发挥作用的函数，在其他作用域中调用不会发挥作用。

### 5.4.1 现象

- panic 只会触发当前 Goroutine 的 defer；
- recover 只有在 defer 中调用才会生效；
- panic 允许在 defer 中嵌套多次调用。

#### 跨协程失效

```go
func main() {
    defer println("in main")
    go func() {
        defer println("in goroutine")
        panic("")
    }()

    time.Sleep(1 * time.Second)
}

$ go run main.go
in goroutine
panic:
...
```

运行这段代码时发现 main 函数的 defer 并没有执行，执行的只是当前 goroutine 中的 defer 。

前面我们曾经介绍过 `defer` 关键字对应的 `runtime.deferproc` 会将延迟调用函数与调用方所在 `Goroutine` 进行关联。所以当程序发生崩溃时只会调用当前 `Goroutine` 的延迟调用函数也是非常合理的。

![image](https://mail.wangkekai.cn/B5A47EC2-1508-4930-B114-09C4AEF9F213.png)

如上图所示，多个 Goroutine 之间没有太多的关联，一个 Goroutine 在 panic 时也不应该执行其他 Goroutine 的延迟函数。

#### 失效的崩溃恢复

```go
func main() {
    defer fmt.Println("in main")
    if err := recover(); err != nil {
        fmt.Println(err)
    }

    panic("unknown err")
}

$ go run main.go
in main
panic: unknown err

goroutine 1 [running]:
main.main()
    ...
exit status 2
```

`recover` 只有在发生 `panic` 之后调用才会生效。然而在上面的控制流中，`recover` 是在 `panic` 之前调用的，并不满足生效的条件，**所以我们需要在 `defer` 中使用 `recover` 关键字**。

#### 嵌套崩溃

```go
func main() {
    defer fmt.Println("in main")
    defer func() {
        defer func() {
            panic("panic again and again")
        }()
        panic("panic again")
    }()

    panic("panic once")
}

$ go run main.go
in main
panic: panic once
    panic: panic again
    panic: panic again and again

goroutine 1 [running]:
...
exit status 2
```

## 5.5 make 和 new

初始化一个结构时，可能会用到两个不同的关键字： `make` 和 `new`

- `make` 的作用是初始化内置的数据结构，也就是我们在前面提到的切片、哈希表和 Channel；
- `new` 的作用是根据传入的类型分配一片内存空间并返回指向这片内存空间的指针；

```go
slice := make([]int, 0, 100)
hash := make(map[int]bool, 10)
ch := make(chan int, 5)
```

1. `slice` 是一个包含 `data`、`cap` 和 `len` 的结构体 `reflect.SliceHeader`；
2. `hash` 是一个指向 `runtime.hmap` 结构体的指针；
3. `ch` 是一个指向 `runtime.hchan` 结构体的指针；

`new` 的功能就简单多了，它只能接收类型作为参数然后返回一个指向该类型的指针：

```go
i := new(int)

var v int
i := &v
```

上述代码片段中的两种不同初始化方法是等价的，它们都会创建一个指向 int 零值的指针。

### 5.5.1 make

在编译期间的类型检查阶段，Go 语言会将代表 `make` 关键字的 `OMAKE` 节点根据参数类型的不同转换成了 OMAKESLICE、OMAKEMAP 和 OMAKECHAN 三种不同类型的节点，这些节点会调用不同的运行时函数来初始化相应的数据结构。

### 5.5.2 new

编译器会在中间代码生成阶段通过以下两个函数处理该关键字：

1. `cmd/compile/internal/gc.callnew` 会将关键字转换成 ONEWOBJ 类型的节点2；
2. `cmd/compile/internal/gc.state.expr` 会根据申请空间的大小分两种情况处理：
   1. 如果申请的空间为 0，就会返回一个表示空指针的 `zerobase` 变量；
   2. 在遇到其他情况时会将关键字转换成 `runtime.newobject` 函数：

```go
func callnew(t *types.Type) *Node {
    ...
    n := nod(ONEWOBJ, typename(t), nil)
    ...
    return n
}

func (s *state) expr(n *Node) *ssa.Value {
    switch n.Op {
    case ONEWOBJ:
        if n.Type.Elem().Size() == 0 {
            return s.newValue1A(ssa.OpAddr, n.Type, zerobaseSym, s.sb)
        }
        typ := s.expr(n.Left)
        vv := s.rtcall(newobject, true, []*types.Type{n.Type}, typ)
        return vv[0]
    }
}
```

需要注意的是，无论是直接使用 `new`，还是使用 `var` 初始化变量，它们在编译器看来都是 `ONEW` 和 `ODCL` 节点。如果变量会逃逸到堆上，这些节点在这一阶段都会被 `cmd/compile/internal/gc.walkstmt` 转换成通过 `runtime.newobject` 函数并在堆上申请内存：

```go
func walkstmt(n *Node) *Node {
    switch n.Op {
    case ODCL:
        v := n.Left
        if v.Class() == PAUTOHEAP {
            if prealloc[v] == nil {
                prealloc[v] = callnew(v.Type)
            }
            nn := nod(OAS, v.Name.Param.Heapaddr, prealloc[v])
            nn.SetColas(true)
            nn = typecheck(nn, ctxStmt)
            return walkstmt(nn)
        }
    case ONEW:
        if n.Esc == EscNone {
            r := temp(n.Type.Elem())
            r = nod(OAS, r, nil)
            r = typecheck(r, ctxStmt)
            init.Append(r)
            r = nod(OADDR, r.Left, nil)
            r = typecheck(r, ctxExpr)
            n = r
        } else {
            n = callnew(n.Type.Elem())
        }
    }
}
```

不过这也不是绝对的，**如果通过 `var` 或者 `new` 创建的变量不需要在当前作用域外生存，例如不用作为返回值返回给调用方，那么就不需要初始化在堆上**。
